    function updateWaypointsList() {
      const listEl = document.getElementById('waypoint-list');
      
      if (waypoints.length === 0) {
        listEl.style.display = 'none';
        return;
      }
      
      listEl.style.display = 'block';
      listEl.innerHTML = '';
      
      waypoints.forEach((waypoint, index) => {
        const item = document.createElement('div');
        item.className = 'waypoint-item';
        
        item.innerHTML = `
          <div class="waypoint-number">${index + 1}</div>
          <div class="waypoint-text" title="${waypoint.name}">${waypoint.name}</div>
          <div class="waypoint-controls">
            <button onclick="moveWaypointUp(${index})" ${index === 0 ? 'disabled' : ''}>‚Üë</button>
            <button onclick="moveWaypointDown(${index})" ${index === waypoints.length - 1 ? 'disabled' : ''}>‚Üì</button>
            <button onclick="removeWaypoint(${index})">√ó</button>
          </div>
        `;
        
        listEl.appendChild(item);
      });
    }

    function moveWaypointUp(index) {
      if (index > 0) {
        const temp = waypoints[index];
        waypoints[index] = waypoints[index - 1];
        waypoints[index - 1] = temp;
        updateWaypointsList();
        updateWaypoints();
      }
    }

    function moveWaypointDown(index) {
      if (index < waypoints.length - 1) {
        const temp = waypoints[index];
        waypoints[index] = waypoints[index + 1];
        waypoints[index + 1] = temp;
        updateWaypointsList();
        updateWaypoints();
      }
    }

    function removeWaypoint(index) {
      waypoints.splice(index, 1);
      updateWaypointsList();
      updateWaypoints();
    }

    async function findRoute() {
      if (!origin || !destination) {
        updateStatus('<strong>‚ùå Missing Points</strong><br>Set origin and destination first', 'error');
        return;
      }

      const profile = document.getElementById('profile-select').value;
      
      let coords = origin.join(',');
      waypoints.forEach(waypoint => {
        coords += ';' + waypoint.coordinates.join(',');
      });
      coords += ';' + destination.join(',');
      
      const url = `https://api.mapbox.com/directions/v5/mapbox/${profile}/${coords}?geometries=geojson&access_token=${MAPBOX_TOKEN}`;

      updateStatus('<strong>üîÑ Finding Route...</strong><br>Planning route...', 'loading');

      try {
        const response = await fetch(url);
        const data = await response.json();

        if (data.routes && data.routes.length > 0) {
          const route = data.routes[0];
          
          map.getSource('route').setData(route.geometry);
          
          const obstacle = turf.buffer(clearances, 0.25, { units: 'kilometers' });
          const clear = turf.booleanDisjoint(obstacle, route.geometry);
          
          const duration = Math.round(route.duration / 60);
          const distance = (route.distance / 1000).toFixed(1);
          
          if (clear) {
            updateStatus(`<strong>‚úÖ Safe Route!</strong><br>${duration} min, ${distance} km`, 'success');
            map.setPaintProperty('route', 'line-color', '#00ff00');
          } else {
            updateStatus(`<strong>‚ö†Ô∏è Obstacle Warning!</strong><br>${duration} min, ${distance} km`, 'error');
            map.setPaintProperty('route', 'line-color', '#ff0000');
          }
          
          const bounds = turf.bbox(route.geometry);
          map.fitBounds(bounds, { padding: 50 });
        }
      } catch (error) {
        updateStatus('<strong>‚ùå Route Error</strong><br>Could not find route', 'error');
      }
    }

    function clearRoute() {
      origin = null;
      destination = null;
      waypoints = [];
      isSettingOrigin = true;
      
      document.getElementById('origin-input').value = '';
      document.getElementById('destination-input').value = '';
      document.getElementById('waypoint-input').value = '';
      
      updateWaypointsList();
      
      if (map && map.getSource('route')) {
        map.getSource('route').setData({ type: 'FeatureCollection', features: [] });
      }
      if (map && map.getSource('waypoints')) {
        map.getSource('waypoints').setData({ type: 'FeatureCollection', features: [] });
      }
      
      updateStatus('<strong>üéØ Ready</strong><br>Enter addresses or click map', 'loading');
    }

    function changeMapStyle(type) {
      if (!map) return;
      
      let styleUrl;
      if (type === 'custom') {
        styleUrl = document.getElementById('customStyleSelector').value;
        if (!styleUrl) return;
        document.getElementById('styleSelector').selectedIndex = 0;
      } else {
        styleUrl = document.getElementById('styleSelector').value;
        document.getElementById('customStyleSelector').selectedIndex = 0;
      }
      
      const routeData = map.getSource('route') ? map.getSource('route')._data : null;
      const waypointData = map.getSource('waypoints') ? map.getSource('waypoints')._data : null;
      
      map.setStyle(styleUrl);
      
      map.once('style.load', function() {
        setupMapFeatures();
        
        setTimeout(() => {
          if (routeData && map.getSource('route')) {
            map.getSource('route').setData(routeData);
          }
          if (waypointData && map.getSource('waypoints')) {
            map.getSource('waypoints').setData(waypointData);
          }
          updateCenterPoint();
          updateRouteStyle();
        }, 200);
      });
    }

    function updateRouteStyle() {
      if (!map || !map.getLayer('route')) return;
      
      const color = document.getElementById('routeColor').value;
      const width = parseInt(document.getElementById('routeWidth').value);
      
      map.setPaintProperty('route', 'line-color', color);
      map.setPaintProperty('route', 'line-width', width);
    }

    function zoomIn() {
      if (customCenter) {
        map.zoomTo(map.getZoom() + 1, { center: customCenter });
      } else {
        map.zoomIn();
      }
    }

    function zoomOut() {
      if (customCenter) {
        map.zoomTo(map.getZoom() - 1, { center: customCenter });
      } else {
        map.zoomOut();
      }
    }

    function fitToData() {
      const allPoints = [];
      if (origin) allPoints.push(turf.point(origin));
      waypoints.forEach(wp => allPoints.push(turf.point(wp.coordinates)));
      if (destination) allPoints.push(turf.point(destination));
      
      if (allPoints.length === 0) {
        const bounds = turf.bbox(clearances);
        map.fitBounds(bounds, { padding: 50 });
      } else if (allPoints.length === 1) {
        map.flyTo({ center: allPoints[0].geometry.coordinates, zoom: 12 });
      } else {
        const collection = turf.featureCollection(allPoints);
        const bounds = turf.bbox(collection);
        map.fitBounds(bounds, { padding: 100 });
      }
    }

    function toggleCenterMode() {
      isSettingCenter = !isSettingCenter;
      updateCenterModeButton();
      
      if (isSettingCenter) {
        updateStatus('<strong>üéØ Center Mode</strong><br>Click map to set center point', 'loading');
      } else {
        updateStatus('<strong>üéØ Ready</strong><br>Center mode disabled', 'success');
      }
    }

    function updateCenterModeButton() {
      const btn = document.getElementById('center-mode-btn');
      if (isSettingCenter) {
        btn.textContent = '‚ùå Cancel';
        btn.style.backgroundColor = '#dc3545';
      } else {
        btn.textContent = 'üéØ Set Center';
        btn.style.backgroundColor = '#007bff';
      }
    }

    function toggleCenterIcon() {
      showCenterIcon = !showCenterIcon;
      const btn = document.getElementById('center-icon-btn');
      
      if (showCenterIcon) {
        btn.textContent = 'üëÅÔ∏è';
        btn.style.backgroundColor = '#007bff';
        if (map && map.getLayer('center-point-symbol')) {
          map.setLayoutProperty('center-point-symbol', 'visibility', 'visible');
        }
      } else {
        btn.textContent = 'üö´';
        btn.style.backgroundColor = '#6c757d';
        if (map && map.getLayer('center-point-symbol')) {
          map.setLayoutProperty('center-point-symbol', 'visibility', 'none');
        }
      }
    }

    function setCenterFromInput() {
      const input = document.getElementById('center-input').value.trim();
      if (!input) return;
      
      try {
        const parts = input.split(',').map(p => parseFloat(p.trim()));
        if (parts.length !== 2 || isNaN(parts[0]) || isNaN(parts[1])) {
          throw new Error('Invalid format');
        }
        
        const [lat, lng] = parts;
        customCenter = [lng, lat];
        updateCenterPoint();
        map.flyTo({ center: customCenter, zoom: map.getZoom() });
        updateStatus('<strong>‚úÖ Center Applied!</strong><br>Custom center point set', 'success');
      } catch (error) {
        updateStatus('<strong>‚ùå Invalid Coordinates</strong><br>Use format: lat, lng', 'error');
      }
    }

    function clearCustomCenter() {
      customCenter = null;
      document.getElementById('center-input').value = '';
      updateCenterPoint();
      updateStatus('<strong>‚úÖ Center Cleared</strong><br>Back to normal behavior', 'success');
    }

    function updateCenterPoint() {
      if (!map || !map.getSource('center-point')) return;
      
      const features = [];
      if (customCenter) {
        features.push({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: customCenter },
          properties: {}
        });
      }
      
      map.getSource('center-point').setData({
        type: 'FeatureCollection',
        features: features
      });
    }

    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      const toggleBtn = document.getElementById('toggle-btn');
      
      if (sidebar.classList.contains('hidden')) {
        sidebar.classList.remove('hidden');
        toggleBtn.classList.remove('sidebar-hidden');
        toggleBtn.classList.add('sidebar-visible');
        toggleBtn.innerHTML = '‚ò∞';
      } else {
        sidebar.classList.add('hidden');
        toggleBtn.classList.remove('sidebar-visible');
        toggleBtn.classList.add('sidebar-hidden');
        toggleBtn.innerHTML = '‚ò∞';
      }
    }

    // Initialize immediately when script loads
    logDebug('Script loaded, checking Mapbox GL...');
    
    if (typeof mapboxgl !== 'undefined') {
      logDebug('‚úÖ Mapbox GL available');
      setTimeout(initializeMap, 100);
    } else {
      logDebug('‚ùå Mapbox GL not available');
      updateStatus('<strong>‚ùå Mapbox GL Missing</strong><br>Click "Try Initialize Map"', 'error');
    }

    // Also try on window load
    window.addEventListener('load', function() {
      if (!map && typeof mapboxgl !== 'undefined') {
        logDebug('Window loaded, trying initialization...');
        setTimeout(initializeMap, 100);
      }
    });
  </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Route Finder with Obstacle Avoidance</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   
  <!-- Load Mapbox GL JS -->
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  
  <!-- Load Turf.js -->
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  
  <style type="text/css">
    body {
      margin: 0;
      padding: 0;
      font-family: 'Open Sans', sans-serif;
      background-color: #f0f0f0;
    }
     
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }
     
    .sidebar {
      position: absolute;
      margin: 20px 20px 30px 20px;
      width: 15%;
      min-width: 300px;
      max-height: calc(100vh - 100px);
      top: 0;
      padding: 20px;
      background-color: #fff;
      overflow-y: auto;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      border-radius: 5px;
      z-index: 1000;
      transition: transform 0.3s ease;
    }

    .sidebar.hidden {
      transform: translateX(-100%);
    }

    .toggle-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 40px;
      height: 40px;
      background-color: #fff;
      border: 2px solid #007bff;
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      z-index: 1001;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      transition: left 0.3s ease;
    }

    .toggle-btn.sidebar-hidden {
      left: 20px;
    }

    .toggle-btn.sidebar-visible {
      left: 360px;
    }
     
    .card {
      font-size: small;
      border-bottom: solid #d3d3d3 2px;
      margin-bottom: 6px;
    }
     
    .card-header {
      font-weight: bold;
      padding: 6px;
    }
     
    .no-route {
      background-color: #d3d3d3;
      color: #f00;
    }
     
    .obstacle-found {
      background-color: #f8d7da;
      color: #721c24;
    }
     
    .route-found {
      background-color: #d4edda;
      color: #155724;
    }
     
    .card-details {
      padding: 3px 6px;
    }

    .control-panel {
      background-color: #ffffff;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }

    .input-group {
      margin-bottom: 10px;
    }

    .input-group label {
      display: block;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .input-group input, .input-group select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
    }

    .route-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }

    .route-controls input[type="color"] {
      width: 40px;
      height: 30px;
      padding: 0;
      border: none;
    }

    .route-controls input[type="number"] {
      width: 60px;
    }

    .status-message {
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      font-size: 14px;
    }

    .status-loading {
      background-color: #fff3cd;
      border: 1px solid #ffeaa7;
      color: #856404;
    }

    .status-success {
      background-color: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
    }

    .status-error {
      background-color: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
    }

    button {
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      border: none;
      border-radius: 4px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background-color: #0056b3;
    }

    button:disabled {
      background-color: #6c757d;
      cursor: not-allowed;
    }

    .diagnostic-info {
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      padding: 10px;
      margin: 10px 0;
      font-size: 12px;
      font-family: monospace;
      max-height: 200px;
      overflow-y: auto;
    }

    .network-test {
      background-color: #e3f2fd;
      border: 1px solid #90caf9;
      border-radius: 5px;
      padding: 10px;
      margin: 10px 0;
      font-size: 13px;
    }

    .zoom-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .zoom-controls button {
      width: 50px;
      height: 40px;
      font-size: 18px;
      font-weight: bold;
    }

    .waypoint-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #f9f9f9;
    }

    .waypoint-item {
      display: flex;
      align-items: center;
      padding: 8px;
      border-bottom: 1px solid #eee;
      background-color: white;
      margin: 2px;
      border-radius: 3px;
    }

    .waypoint-item:last-child {
      border-bottom: none;
    }

    .waypoint-number {
      width: 25px;
      height: 25px;
      border-radius: 50%;
      background-color: #007bff;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      margin-right: 10px;
      flex-shrink: 0;
    }

    .waypoint-text {
      flex: 1;
      font-size: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .waypoint-controls {
      display: flex;
      gap: 5px;
      flex-shrink: 0;
    }

    .waypoint-controls button {
      width: 25px;
      height: 25px;
      padding: 0;
      font-size: 12px;
      margin: 0;
    }
  </style>
</head>
 
<body>
  <div id="map"></div>
  
  <div class="toggle-btn sidebar-visible" id="toggle-btn" onclick="toggleSidebar()">
    ‚ò∞
  </div>
  
  <div class="sidebar" id="sidebar">
    <div id="status-message" class="status-message status-loading">
      <strong>üîÑ Loading...</strong><br>
      Initializing map...
    </div>

    <div class="control-panel">
      <div class="input-group">
        <label>üü¢ Starting Point:</label>
        <input type="text" id="origin-input" placeholder="Enter address or place name">
        <button onclick="geocodeOrigin()" style="margin-top: 5px; font-size: 12px; height: 30px;">üìç Find Location</button>
      </div>
      
      <div class="input-group">
        <label>üî¥ Destination:</label>
        <input type="text" id="destination-input" placeholder="Enter address or place name">
        <button onclick="geocodeDestination()" style="margin-top: 5px; font-size: 12px; height: 30px;">üìç Find Location</button>
      </div>
      
      <div class="input-group">
        <label>üîµ Waypoints:</label>
        <input type="text" id="waypoint-input" placeholder="Enter intermediate stop">
        <button onclick="addWaypoint()" style="margin-top: 5px; font-size: 12px; height: 30px;">‚ûï Add Waypoint</button>
        
        <div id="waypoint-list" class="waypoint-list" style="margin-top: 10px; display: none;">
          <!-- Waypoints will be added here dynamically -->
        </div>
      </div>
      
      <div class="input-group">
        <label>üöó Travel Mode:</label>
        <select id="profile-select">
          <option value="driving">üöó Driving</option>
          <option value="walking">üö∂ Walking</option>
          <option value="cycling">üö¥ Cycling</option>
        </select>
      </div>
      
      <button onclick="findRoute()">üó∫Ô∏è Find Route</button>
      <button onclick="clearRoute()">üóëÔ∏è Clear All</button>
      
      <div class="zoom-controls">
        <button onclick="zoomIn()">+</button>
        <button onclick="zoomOut()">-</button>
        <button onclick="fitToData()" style="width: auto; flex: 1; font-size: 14px;">üìç Fit to Points</button>
      </div>
      
      <div class="zoom-controls">
        <button onclick="toggleCenterMode()" id="center-mode-btn" style="width: auto; flex: 1; font-size: 14px;">üéØ Set Center</button>
        <button onclick="toggleCenterIcon()" id="center-icon-btn" style="width: 50px; font-size: 14px;">üëÅÔ∏è</button>
      </div>
      
      <div class="input-group" style="margin-top: 10px;">
        <label style="font-size: 12px;">Custom Center (lat, lng):</label>
        <input type="text" id="center-input" placeholder="38.0500, -84.5000" style="font-size: 12px;">
        <button onclick="setCenterFromInput()" style="margin-top: 5px; font-size: 12px; height: 30px;">üìç Apply Center</button>
        <button onclick="clearCustomCenter()" style="margin-top: 5px; font-size: 12px; height: 30px;">‚ùå Clear Center</button>
      </div>
      
      <div class="route-controls">
        <label>Color:</label>
        <input type="color" id="routeColor" value="#ff0000" onchange="updateRouteStyle()">
        <label>Width:</label>
        <input type="number" id="routeWidth" value="8" min="1" max="20" onchange="updateRouteStyle()">
      </div>
    </div>

    <div class="control-panel">
      <div class="input-group">
        <label><strong>Default Map Styles:</strong></label>
        <select id="styleSelector" onchange="changeMapStyle()">
          <option value="mapbox://styles/mapbox/streets-v11">üìç Streets</option>
          <option value="mapbox://styles/mapbox/outdoors-v11">üå≤ Outdoors</option>
          <option value="mapbox://styles/mapbox/light-v10">‚òÄÔ∏è Light</option>
          <option value="mapbox://styles/mapbox/dark-v10">üåô Dark</option>
          <option value="mapbox://styles/mapbox/satellite-v9">üõ∞Ô∏è Satellite</option>
          <option value="mapbox://styles/mapbox/satellite-streets-v11">üó∫Ô∏è Satellite Streets</option>
        </select>
      </div>
      
      <div class="input-group">
        <label><strong>Your Custom Styles:</strong></label>
        <select id="customStyleSelector" onchange="changeMapStyle('custom')">
          <option value="">Select custom style...</option>
          <option value="mapbox://styles/cb29/ckxnnmex53n1b14m07t6sum48">üé® Classic Standard</option>
          <option value="mapbox://styles/cb29/ckxnmjiti0rvm14pby8w9si99">üé® Classic Vintage</option>
          <option value="mapbox://styles/cb29/ckxov33jj3le314ueu15gl6yh">üé® Dark Digital</option>
          <option value="mapbox://styles/cb29/ckxmhuc4k2gxm14s0eq1htzns">üé® Dark Monochrome</option>
          <option value="mapbox://styles/cb29/ckxs1bfov2cay14mnx6nvrzxt">üé® Dark Night Mode</option>
          <option value="mapbox://styles/cb29/ckwgtu6ly20cr15qiy9i2ftsz">üé® Light Engraved</option>
          <option value="mapbox://styles/cb29/ckxntkwjq4flv14ld7uisp5b1">üé® Light High Contrast</option>
          <option value="mapbox://styles/cb29/ckxouv50s02lw14r2jiyvnvxh">üé® Light Pencil Sketch</option>
          <option value="mapbox://styles/cb29/ckxtl08qj2gb215p8y2blzxur">üé® Pastel Blue</option>
          <option value="mapbox://styles/cb29/ckxtlkuk8l10zj14pk8irf7owt">üé® Pastel Cool</option>
          <option value="mapbox://styles/cb29/ckxtl2a2s0yot14nw9pbn2733">üé® Pastel Pink</option>
          <option value="mapbox://styles/cb29/ckxtl35nk4hsb15mry8rwlg4l">üé® Pastel Yellow</option>
          <option value="mapbox://styles/cb29/ckxmjckme2if514s0v3xq4vxy">üé® Satellite Streets</option>
          <option value="mapbox://styles/cb29/ckxrnuq691z6h14mnuy5jpk5c">üé® Topography Colorful</option>
          <option value="mapbox://styles/cb29/ckxnp39kb5eyw14oaan01mkp0">üé® Topography Globe</option>
          <option value="mapbox://styles/cb29/ckxnkf6rs60r214uc0j42vbj4">üé® Topography Outdoor</option>
          <option value="mapbox://styles/cb29/ckxnqwyww0sri14p9skglgshs">üé® Topography Subtle</option>
          <option value="mapbox://styles/cb29/ckxno9jbk3nn714s6vjah6fwb">üé® Topography Vintage</option>
          <option value="mapbox://styles/cb29/ckxrrtfqk0oir15my0y9tpjvj">üé® Unique Colorful</option>
          <option value="mapbox://styles/cb29/ckxovchyg4tfj14s6d7u559tj">üé® Unique Comic Book 1</option>
          <option value="mapbox://styles/cb29/ckxov6vgm66g214o064dp3vda">üé® Unique Comic Book 2</option>
          <option value="mapbox://styles/cb29/ckxove5sy174l15mq6h82hwxk">üé® Unique Dusty Western</option>
          <option value="mapbox://styles/cb29/ckxoup98z4sv514m0q988ltie">üé® Unique Picture Book</option>
          <option value="mapbox://styles/cb29/ckxov1ris0n2415p4e9gn8oxu">üé® Unique Treasure Map</option>
          <option value="mapbox://styles/cb29/ckxous4km02k114m523qh0k9y">üé® Unique Woodcut</option>
        </select>
      </div>
    </div>

    <div class="network-test">
      <strong>üîç Debug Info:</strong>
      <div id="diagnostic-results" class="diagnostic-info">Starting...</div>
    </div>

    <button onclick="initializeMap()">üîÑ Try Initialize Map</button>
    <button onclick="debugStatus()">üîç Debug Status</button>

    <div id="reports"></div>
  </div>

  <script>
    // Your Mapbox access token
    const MAPBOX_TOKEN = 'pk.eyJ1IjoiY2IyOSIsImEiOiJja3E4OHo3anowZGx1Mm9tcXF3ZmhyaWtwIn0.IQ5rY622AU9GOETrqa9NBw';

    // Global variables
    let map = null;
    let origin = null;
    let destination = null;
    let waypoints = [];
    let isSettingOrigin = true;
    let customCenter = null;
    let isSettingCenter = false;
    let showCenterIcon = true;

    // Obstacle data
    const clearances = {
      type: 'FeatureCollection',
      features: [
        {
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [-84.47426, 38.06673] },
          properties: { clearance: "13' 2\"" }
        },
        {
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [-84.47208, 38.06694] },
          properties: { clearance: "13' 7\"" }
        },
        {
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [-84.60485, 38.12184] },
          properties: { clearance: "13' 7\"" }
        },
        {
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [-84.61905, 37.87504] },
          properties: { clearance: "12' 0\"" }
        },
        {
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [-84.55946, 38.30213] },
          properties: { clearance: "13' 6\"" }
        },
        {
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [-84.27235, 38.04954] },
          properties: { clearance: "13' 6\"" }
        },
        {
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [-84.27264, 37.82917] },
          properties: { clearance: "11' 6\"" }
        }
      ]
    };

    function logDebug(message) {
      console.log(message);
      const debugEl = document.getElementById('diagnostic-results');
      if (debugEl) {
        debugEl.innerHTML += message + '<br>';
        debugEl.scrollTop = debugEl.scrollHeight;
      }
    }

    function updateStatus(message, type) {
      const statusEl = document.getElementById('status-message');
      statusEl.className = 'status-message status-' + type;
      statusEl.innerHTML = message;
    }

    function debugStatus() {
      logDebug('=== DEBUG STATUS ===');
      logDebug('Mapbox GL exists: ' + (typeof mapboxgl !== 'undefined'));
      logDebug('Map instance: ' + (map ? 'exists' : 'null'));
      logDebug('Document ready: ' + document.readyState);
      logDebug('=== END DEBUG ===');
    }

    function initializeMap() {
      logDebug('Starting map initialization...');
      updateStatus('<strong>üó∫Ô∏è Initializing...</strong><br>Creating map instance...', 'loading');
      
      if (typeof mapboxgl === 'undefined') {
        logDebug('‚ùå Mapbox GL not found');
        updateStatus('<strong>‚ùå Mapbox GL Missing</strong><br>Library failed to load', 'error');
        return;
      }
      
      logDebug('‚úÖ Mapbox GL found');
      
      mapboxgl.accessToken = MAPBOX_TOKEN;
      
      map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/streets-v11',
        center: [-84.5, 38.05],
        zoom: 10
      });
      
      map.on('load', function() {
        logDebug('‚úÖ Map loaded!');
        updateStatus('<strong>‚úÖ Ready!</strong><br>Click map or enter addresses', 'success');
        setupMapFeatures();
      });
      
      map.on('error', function(e) {
        logDebug('‚ùå Map error: ' + (e.error ? e.error.message : 'unknown'));
        updateStatus('<strong>‚ùå Map Error</strong><br>Failed to load', 'error');
      });
      
      map.on('click', handleMapClick);
    }

    function setupMapFeatures() {
      // Add obstacles
      const obstacle = turf.buffer(clearances, 0.25, { units: 'kilometers' });
      
      map.addSource('obstacles', {
        type: 'geojson',
        data: obstacle
      });

      map.addLayer({
        id: 'obstacles',
        type: 'fill',
        source: 'obstacles',
        paint: {
          'fill-color': '#ff0000',
          'fill-opacity': 0.3
        }
      });
      
      // Add route source
      map.addSource('route', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });

      map.addLayer({
        id: 'route',
        type: 'line',
        source: 'route',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: { 'line-color': '#ff0000', 'line-width': 8 }
      });
      
      // Add waypoints source
      map.addSource('waypoints', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });

      map.addLayer({
        id: 'waypoints',
        type: 'circle',
        source: 'waypoints',
        paint: {
          'circle-radius': 2,
          'circle-color': ['get', 'color'],
          'circle-stroke-color': '#ffffff',
          'circle-stroke-width': 1
        }
      });
      
      // Add center point source
      map.addSource('center-point', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });

      map.addLayer({
        id: 'center-point-symbol',
        type: 'symbol',
        source: 'center-point',
        layout: {
          'text-field': '‚äï',
          'text-size': 20,
          'text-allow-overlap': true,
          'text-ignore-placement': true
        },
        paint: {
          'text-color': '#ff0000',
          'text-halo-color': '#ffffff',
          'text-halo-width': 2
        }
      });
      
      logDebug('‚úÖ Map features setup complete');
    }

    function handleMapClick(e) {
      const coords = [e.lngLat.lng, e.lngLat.lat];
      
      if (isSettingCenter) {
        customCenter = coords;
        document.getElementById('center-input').value = coords[1].toFixed(4) + ', ' + coords[0].toFixed(4);
        updateCenterPoint();
        map.setCenter(coords);
        isSettingCenter = false;
        updateCenterModeButton();
        updateStatus('<strong>‚úÖ Center Set!</strong><br>Zoom operations will center here', 'success');
        return;
      }
      
      if (isSettingOrigin) {
        origin = coords;
        reverseGeocode(coords, 'origin');
        isSettingOrigin = false;
      } else {
        destination = coords;
        reverseGeocode(coords, 'destination');
        isSettingOrigin = true;
      }
      
      updateWaypoints();
    }

    async function reverseGeocode(coords, type) {
      try {
        const response = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${coords[0]},${coords[1]}.json?access_token=${MAPBOX_TOKEN}`);
        const data = await response.json();
        
        if (data.features && data.features.length > 0) {
          const placeName = data.features[0].place_name;
          const inputId = type === 'origin' ? 'origin-input' : 'destination-input';
          document.getElementById(inputId).value = placeName;
        }
      } catch (error) {
        const inputId = type === 'origin' ? 'origin-input' : 'destination-input';
        document.getElementById(inputId).value = coords[1].toFixed(4) + ', ' + coords[0].toFixed(4);
      }
    }

    function updateWaypoints() {
      const features = [];
      
      if (origin) {
        features.push({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: origin },
          properties: { color: '#00ff00' }
        });
      }
      
      waypoints.forEach((waypoint, index) => {
        features.push({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: waypoint.coordinates },
          properties: { color: '#0066ff' }
        });
      });
      
      if (destination) {
        features.push({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: destination },
          properties: { color: '#ff6600' }
        });
      }

      if (map && map.getSource('waypoints')) {
        map.getSource('waypoints').setData({
          type: 'FeatureCollection',
          features: features
        });
      }
    }

    async function geocodeOrigin() {
      const address = document.getElementById('origin-input').value.trim();
      if (!address) return;
      await geocodeAddress(address, 'origin');
    }

    async function geocodeDestination() {
      const address = document.getElementById('destination-input').value.trim();
      if (!address) return;
      await geocodeAddress(address, 'destination');
    }

    async function geocodeAddress(address, type) {
      try {
        const response = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(address)}.json?access_token=${MAPBOX_TOKEN}&limit=1`);
        const data = await response.json();
        
        if (data.features && data.features.length > 0) {
          const coords = data.features[0].center;
          const placeName = data.features[0].place_name;
          
          if (type === 'origin') {
            origin = coords;
          } else {
            destination = coords;
          }
          
          const inputId = type === 'origin' ? 'origin-input' : 'destination-input';
          document.getElementById(inputId).value = placeName;
          
          updateWaypoints();
          map.flyTo({ center: coords, zoom: 14 });
          updateStatus('<strong>‚úÖ Location Found!</strong><br>' + placeName, 'success');
        }
      } catch (error) {
        updateStatus('<strong>‚ùå Location Error</strong><br>Could not find address', 'error');
      }
    }

    async function addWaypoint() {
      const address = document.getElementById('waypoint-input').value.trim();
      if (!address) return;
      
      try {
        const response = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(address)}.json?access_token=${MAPBOX_TOKEN}&limit=1`);
        const data = await response.json();
        
        if (data.features && data.features.length > 0) {
          const coords = data.features[0].center;
          const placeName = data.features[0].place_name;
          
          waypoints.push({
            coordinates: coords,
            name: placeName,
            id: Date.now()
          });
          
          document.getElementById('waypoint-input').value = '';
          updateWaypointsList();
          updateWaypoints();
          updateStatus('<strong>‚úÖ Waypoint Added!</strong><br>' + placeName, 'success');
        }
      } catch (error) {
        updateStatus('<strong>‚ùå Waypoint Error</strong><br>Could not find address', 'error');
      }
    }

    function updateWaypointsList() {
      const listEl = document.getElementById('waypoint-list');
      
      if (waypoints.length === 0) {
        listEl.style.display = 'none';
        return;
      }
      
      listEl
