<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Route Finder with Multiple Routes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  
  <style>
    /* ===== CSS VARIABLES ===== */
    :root {
      --color-primary: #3b82f6;
      --color-primary-hover: #2563eb;
      --color-primary-alpha: rgba(59, 130, 246, 0.1);
      --color-success: #10b981;
      --color-warning: #f59e0b;
      --color-danger: #ef4444;
      
      --color-text-primary: #1f2937;
      --color-text-secondary: #6b7280;
      --color-text-tertiary: #9ca3af;
      
      --color-surface-primary: #ffffff;
      --color-surface-secondary: #f9fafb;
      --color-surface-hover: #f3f4f6;
      
      --color-border-light: #e5e7eb;
      --color-border-hover: #d1d5db;
      
      --space-1: 0.25rem;
      --space-2: 0.5rem;
      --space-3: 0.75rem;
      --space-4: 1rem;
      --space-5: 1.25rem;
      --space-6: 1.5rem;
      --space-8: 2rem;
      --space-10: 2.5rem;
      --space-12: 3rem;
      
      --font-size-xs: 0.75rem;
      --font-size-sm: 0.875rem;
      --font-size-base: 1rem;
      --font-size-lg: 1.125rem;
      --font-size-xl: 1.25rem;
      
      --font-weight-normal: 400;
      --font-weight-medium: 500;
      --font-weight-semibold: 600;
      --font-weight-bold: 700;
      
      --border-radius-sm: 0.25rem;
      --border-radius-md: 0.375rem;
      --border-radius-lg: 0.5rem;
      
      --transition-base: all 0.2s ease;
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
      
      /* Legacy variables for compatibility */
      --radius-md: var(--border-radius-md);
      --color-bg-primary: var(--color-surface-primary);
      --color-bg-secondary: var(--color-surface-secondary);
    }

    /* ===== RESET & BASE ===== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      color: var(--color-text-primary);
      background-color: var(--color-surface-secondary);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
     
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }
     
    .sidebar {
      position: absolute;
      margin: var(--space-5);
      width: 380px;
      max-height: calc(100vh - var(--space-10));
      background-color: var(--color-surface-primary);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-lg);
      box-shadow: var(--shadow-lg);
      overflow-y: auto;
      z-index: 1000;
      transition: var(--transition-base);
      padding-bottom: 0;
    }

    /* Main Container */
    .sidebar-container {
      padding: var(--space-5);
      display: flex;
      flex-direction: column;
      gap: var(--space-4);
    }

    /* Status Message */
    .status-message {
      padding: var(--space-4);
      border-radius: var(--radius-md);
      margin-bottom: var(--space-4);
      font-size: var(--font-size-sm);
      line-height: 1.4;
    }

    .status-loading { 
      background-color: #fef3c7; 
      border: 1px solid #f59e0b; 
      color: #92400e; 
    }
    .status-success { 
      background-color: #d1fae5; 
      border: 1px solid #10b981; 
      color: #065f46; 
    }
    .status-error { 
      background-color: #fee2e2; 
      border: 1px solid #ef4444; 
      color: #991b1b; 
    }
    .status-info { 
      background-color: #dbeafe; 
      border: 1px solid #3b82f6; 
      color: #1e40af; 
    }

    /* Cards */
    .card {
      background: var(--color-surface-primary);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-lg);
      overflow: hidden;
      margin-bottom: var(--space-4);
    }

    .card-header {
      padding: var(--space-4);
      background: var(--color-surface-secondary);
      border-bottom: 1px solid var(--color-border-light);
      font-weight: var(--font-weight-semibold);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: var(--transition-base);
    }

    .card-header:hover {
      background: var(--color-surface-hover);
    }

    .card-header .icon {
      margin-right: var(--space-2);
      font-size: var(--font-size-lg);
    }

    .card-content {
      padding: var(--space-4);
    }

    .collapsible {
      display: block;
      transition: var(--transition-base);
    }

    .collapsible.collapsed {
      display: none;
    }

    .chevron {
      color: var(--color-text-secondary);
      font-size: var(--font-size-sm);
      transition: var(--transition-base);
    }

    .collapsed .chevron {
      transform: rotate(-90deg);
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: var(--space-3) var(--space-4);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-md);
      background: var(--color-surface-primary);
      color: var(--color-text-primary);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      text-decoration: none;
      cursor: pointer;
      transition: var(--transition-base);
      gap: var(--space-2);
    }

    .btn:hover {
      background: var(--color-surface-hover);
      border-color: var(--color-border-hover);
    }

    .btn-primary {
      background: var(--color-primary);
      border-color: var(--color-primary);
      color: white;
    }

    .btn-primary:hover {
      background: var(--color-primary-hover);
      border-color: var(--color-primary-hover);
    }

    .btn-secondary {
      background: var(--color-surface-secondary);
      color: var(--color-text-secondary);
    }

    .btn-full {
      width: 100%;
    }

    .btn-small {
      padding: var(--space-2) var(--space-3);
      font-size: var(--font-size-xs);
    }

    .button-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-3);
    }

    .button-group {
      display: flex;
      gap: var(--space-2);
    }

    /* Form Elements */
    .form-group {
      margin-bottom: var(--space-4);
    }

    .form-label {
      display: block;
      font-weight: var(--font-weight-medium);
      font-size: var(--font-size-sm);
      color: var(--color-text-primary);
      margin-bottom: var(--space-2);
    }

    .form-input,
    .form-select {
      width: 100%;
      padding: var(--space-3);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-md);
      background: var(--color-surface-primary);
      color: var(--color-text-primary);
      font-size: var(--font-size-sm);
      transition: var(--transition-base);
    }

    .form-input:focus,
    .form-select:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px var(--color-primary-alpha);
    }

    /* Route Management */
    .route-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      margin-bottom: var(--space-4);
    }

    .route-tab {
      padding: var(--space-2) var(--space-3);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-md);
      background: var(--color-surface-secondary);
      color: var(--color-text-secondary);
      cursor: pointer;
      font-size: var(--font-size-xs);
      transition: var(--transition-base);
      display: flex;
      align-items: center;
      gap: var(--space-1);
    }

    .route-tab.active {
      background: var(--color-primary);
      color: white;
      border-color: var(--color-primary);
    }

    .route-tab:hover:not(.active) {
      background: var(--color-surface-hover);
    }

    .route-list {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid var(--color-border-light);
      border-radius: var(--radius-md);
      background-color: var(--color-bg-secondary);
      margin-top: var(--space-3);
    }

    .route-list-item {
      display: flex;
      align-items: center;
      padding: var(--space-3);
      border-bottom: 1px solid var(--color-border-light);
      background-color: var(--color-bg-primary);
      margin: var(--space-1);
      border-radius: var(--border-radius-sm);
    }

    .route-list-item:last-child {
      border-bottom: none;
    }

    .route-name {
      flex: 1;
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
    }

    .route-actions {
      display: flex;
      gap: var(--space-1);
    }

    /* Waypoints */
    .waypoint-list {
      margin-top: var(--space-3);
    }

    .waypoint-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-2) var(--space-3);
      background: var(--color-surface-secondary);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-md);
      margin-bottom: var(--space-2);
      font-size: var(--font-size-sm);
    }

    .waypoint-content {
      flex: 1;
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    /* Map Controls */
    .map-crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 2;
    }

    .center-circle {
      width: 20px;
      height: 20px;
      border: 2px solid #3b82f6;
      border-radius: 50%;
      background: rgba(59, 130, 246, 0.1);
      position: relative;
    }

    .center-circle::before,
    .center-circle::after {
      content: '';
      position: absolute;
      background: #3b82f6;
    }

    .center-circle::before {
      width: 2px;
      height: 40px;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
    }

    .center-circle::after {
      width: 40px;
      height: 2px;
      top: 50%;
      left: -20px;
      transform: translateY(-50%);
    }

    .toggle-btn {
      position: absolute;
      top: var(--space-4);
      right: var(--space-4);
      width: 40px;
      height: 40px;
      background: var(--color-surface-primary);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-md);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--font-size-lg);
      z-index: 1001;
      box-shadow: var(--shadow-md);
      transition: var(--transition-base);
    }

    .toggle-btn:hover {
      background: var(--color-surface-hover);
    }

    .sidebar.hidden {
      transform: translateX(-100%);
      margin-left: -380px;
    }

    /* ===== MAP EXPORT DIALOG STYLES ===== */
    /* Matches your existing Route Finder UI theme */

    .export-dialog {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.2s ease-out;
    }

    .export-dialog-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(4px);
    }

    .export-dialog-content {
      position: relative;
      background: var(--color-surface-primary);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-lg);
      box-shadow: var(--shadow-xl);
      width: 90vw;
      max-width: 800px;
      max-height: 90vh;
      overflow: hidden;
      animation: slideIn 0.3s ease-out;
    }

    .export-dialog-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-6);
      border-bottom: 1px solid var(--color-border-light);
      background: var(--color-surface-secondary);
    }

    .export-dialog-header h3 {
      margin: 0;
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .export-dialog-header h3 span {
      font-size: 1.2em;
      opacity: 0.8;
    }

    .btn-close {
      background: none;
      border: none;
      width: 32px;
      height: 32px;
      border-radius: var(--border-radius-md);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--color-text-secondary);
      cursor: pointer;
      transition: var(--transition-base);
    }

    .btn-close:hover {
      background: var(--color-surface-hover);
      color: var(--color-text-primary);
    }

    .btn-close span {
      font-size: 18px;
      line-height: 1;
    }

    .export-dialog-body {
      padding: var(--space-6);
      max-height: 60vh;
      overflow-y: auto;
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: var(--space-8);
    }

    .export-form {
      display: flex;
      flex-direction: column;
      gap: var(--space-6);
    }

    .form-section {
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-md);
      padding: var(--space-4);
      background: var(--color-surface-secondary);
    }

    .form-section h4 {
      margin: 0 0 var(--space-4) 0;
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-4);
    }

    .form-group {
      margin-bottom: var(--space-4);
    }

    .form-group:last-child {
      margin-bottom: 0;
    }

    .form-checkbox {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      cursor: pointer;
      font-size: var(--font-size-sm);
      color: var(--color-text-primary);
    }

    .form-checkbox input[type="checkbox"] {
      display: none;
    }

    .checkmark {
      width: 18px;
      height: 18px;
      border: 2px solid var(--color-border-light);
      border-radius: var(--border-radius-sm);
      background: var(--color-surface-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: var(--transition-base);
      position: relative;
    }

    .form-checkbox input[type="checkbox"]:checked + .checkmark {
      border-color: var(--color-primary);
      background: var(--color-primary);
    }

    .form-checkbox input[type="checkbox"]:checked + .checkmark::after {
      content: '‚úì';
      color: white;
      font-size: 12px;
      font-weight: bold;
    }

    .form-checkbox:hover .checkmark {
      border-color: var(--color-border-hover);
    }

    .custom-size-controls {
      margin-top: var(--space-4);
      padding-top: var(--space-4);
      border-top: 1px solid var(--color-border-light);
    }

    .export-preview-section {
      display: flex;
      flex-direction: column;
      gap: var(--space-4);
    }

    .export-preview-section h4 {
      margin: 0;
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
    }

    .export-preview {
      background: var(--color-surface-secondary);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-md);
      padding: var(--space-4);
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
    }

    .preview-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-2) 0;
      border-bottom: 1px solid var(--color-border-light);
    }

    .preview-item:last-child {
      border-bottom: none;
    }

    .preview-label {
      font-size: var(--font-size-sm);
      color: var(--color-text-secondary);
      font-weight: var(--font-weight-medium);
    }

    .preview-value {
      font-size: var(--font-size-sm);
      color: var(--color-text-primary);
      font-weight: var(--font-weight-semibold);
    }

    .export-dialog-footer {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: var(--space-3);
      padding: var(--space-6);
      border-top: 1px solid var(--color-border-light);
      background: var(--color-surface-secondary);
    }

    .export-dialog-footer .btn {
      min-width: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-2);
    }

    .export-dialog-footer .btn span {
      font-size: 1em;
      opacity: 0.9;
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .export-dialog-content {
        width: 95vw;
        margin: var(--space-4);
      }
      
      .export-dialog-body {
        grid-template-columns: 1fr;
        gap: var(--space-6);
        padding: var(--space-4);
      }
      
      .form-grid {
        grid-template-columns: 1fr;
      }
      
      .export-dialog-header,
      .export-dialog-footer {
        padding: var(--space-4);
      }
      
      .export-dialog-footer {
        flex-wrap: wrap;
      }
      
      .export-dialog-footer .btn {
        flex: 1;
        min-width: auto;
      }

      .sidebar {
        width: 100%;
        position: absolute;
        z-index: 100;
        transform: translateX(-100%);
      }
      
      .sidebar.visible {
        transform: translateX(0);
      }
      
      .main-content {
        width: 100%;
      }
      
      .card {
        margin: var(--space-2);
      }
      
      .form-grid,
      .button-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Loading State */
    .export-dialog .btn:disabled {
      opacity: 0.7;
      cursor: not-allowed;
      pointer-events: none;
    }

    .export-dialog .btn:disabled span:first-child {
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }

    /* Form Validation States */
    .form-input:invalid {
      border-color: var(--color-danger);
    }

    .form-input:invalid:focus {
      border-color: var(--color-danger);
      box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);
    }

    /* Utility Classes for Export Dialog */
    .export-dialog .text-muted {
      color: var(--color-text-secondary);
      font-size: var(--font-size-xs);
    }

    .export-dialog .text-small {
      font-size: var(--font-size-xs);
    }

    .export-dialog .text-center {
      text-align: center;
    }

    /* Custom scrollbar for dialog body */
    .export-dialog-body::-webkit-scrollbar {
      width: 6px;
    }

    .export-dialog-body::-webkit-scrollbar-track {
      background: var(--color-surface-secondary);
    }

    .export-dialog-body::-webkit-scrollbar-thumb {
      background: var(--color-border-light);
      border-radius: 3px;
    }

    .export-dialog-body::-webkit-scrollbar-thumb:hover {
      background: var(--color-border-hover);
    }
  </style>
</head>

<body>
  <!-- Map crosshair indicator -->
  <div id="map-crosshair" class="map-crosshair" style="display: none;">
    <div class="center-circle"></div>
  </div>
  
  <div class="toggle-btn sidebar-visible" id="toggle-btn" onclick="RouteFinderApp.ui.toggleSidebar()">
    ‚ò∞
  </div>
  
  <div class="sidebar" id="sidebar">
    <div class="sidebar-container">
      <div id="status-container">
        <div id="status-message" class="status-message status-loading">
          <strong>üîÑ Initializing...</strong><br>
          Loading mapping application...
        </div>
      </div>

      <!-- Route Management Section -->
      <div class="card" id="route-management" style="display: none;">
        <div class="card-header" onclick="RouteFinderApp.ui.toggleSection('route-management')">
          <div style="display: flex; align-items: center;">
            <span class="icon">‚ö¨</span>
            <span>Route Management</span>
          </div>
          <span class="chevron">‚ñ∑</span>
        </div>
        <div class="card-content collapsible" id="route-management-content">
          <div class="route-tabs" id="route-tabs">
            <!-- Route tabs will be dynamically generated -->
          </div>
          
          <button class="btn btn-primary btn-full" onclick="RouteFinderApp.routes.createNewRoute()">
            <span>+</span> New Route
          </button>
          
          <div class="button-grid" style="margin-top: var(--space-4);">
            <button class="btn btn-secondary" onclick="RouteFinderApp.fileManager.exportRoutes()">
              <span>‚Üë</span> Export
            </button>
            <button class="btn btn-secondary" onclick="RouteFinderApp.fileManager.triggerImportRoutes()">
              <span>‚Üì</span> Import
            </button>
          </div>

          <div class="route-list" id="route-list" style="display: none;">
            <!-- Route list items will be dynamically generated -->
          </div>

          <button class="btn btn-secondary btn-full" onclick="RouteFinderApp.ui.toggleRouteList()" id="route-list-toggle" style="display: none; margin-top: var(--space-3);">
            ‚ãØ Show All Routes
          </button>
        </div>
      </div>

      <!-- Current Route Controls -->
      <div class="card" id="current-route-panel" style="display: none;">
        <div class="card-header" onclick="RouteFinderApp.ui.toggleSection('current-route')">
          <div style="display: flex; align-items: center;">
            <span class="icon">‚Üí</span>
            <span id="current-route-title">Current Route</span>
          </div>
          <span class="chevron">‚ñ∑</span>
        </div>
        <div class="card-content collapsible" id="current-route-content">
          <!-- Origin -->
          <div class="form-group">
            <label class="form-label">
              üìç Origin
            </label>
            <input type="text" id="origin-input" class="form-input" placeholder="Enter starting location or click map">
          </div>

          <!-- Destination -->
          <div class="form-group">
            <label class="form-label">
              üéØ Destination
            </label>
            <input type="text" id="destination-input" class="form-input" placeholder="Enter destination or click map">
          </div>

          <!-- Waypoints -->
          <div class="form-group">
            <label class="form-label">
              üìå Waypoints
            </label>
            <div class="button-grid">
              <button class="btn btn-secondary" onclick="RouteFinderApp.interactions.toggleWaypointMode()" id="waypoint-toggle-btn">
                <span>+</span> Add Waypoint
              </button>
              <button class="btn btn-secondary" onclick="RouteFinderApp.ui.clearWaypoints()" id="clear-waypoints-btn">
                <span>‚úï</span> Clear All
              </button>
            </div>
            <div class="waypoint-list" id="waypoint-list">
              <!-- Waypoints will be dynamically generated -->
            </div>
          </div>

          <!-- Travel Mode -->
          <div class="form-group">
            <label class="form-label">üöó Travel Mode</label>
            <select id="travel-mode" class="form-select">
              <option value="driving">Driving</option>
              <option value="walking">Walking</option>
              <option value="cycling">Cycling</option>
            </select>
          </div>

          <!-- Route Controls -->
          <div class="button-grid">
            <button class="btn btn-primary" onclick="RouteFinderApp.routing.findRoute()" id="find-route-btn">
              <span>üîç</span> Find Route
            </button>
            <button class="btn btn-secondary" onclick="RouteFinderApp.ui.clearCurrentRoute()" id="clear-route-btn">
              <span>üóë</span> Clear
            </button>
          </div>
        </div>
      </div>

      <!-- Map Controls -->
      <div class="card" id="map-controls" style="display: none;">
        <div class="card-header" onclick="RouteFinderApp.ui.toggleSection('map-controls')">
          <div style="display: flex; align-items: center;">
            <span class="icon">üó∫</span>
            <span>Map Controls</span>
          </div>
          <span class="chevron">‚ñ∑</span>
        </div>
        <div class="card-content collapsible" id="map-controls-content">
          <div class="form-group">
            <label class="form-label">Map Style</label>
            <select id="map-style" class="form-select" onchange="RouteFinderApp.ui.changeMapStyle()">
              <option value="mapbox://styles/mapbox/streets-v11">Streets</option>
              <option value="mapbox://styles/mapbox/satellite-v9">Satellite</option>
              <option value="mapbox://styles/mapbox/light-v10">Light</option>
              <option value="mapbox://styles/mapbox/dark-v10">Dark</option>
              <option value="mapbox://styles/mapbox/outdoors-v11">Outdoors</option>
            </select>
          </div>
          
          <div class="button-grid">
            <button class="btn btn-secondary" onclick="RouteFinderApp.ui.zoomToUserLocation()">
              <span>üìç</span> My Location
            </button>
            <button class="btn btn-secondary" onclick="RouteFinderApp.ui.fitMapToRoutes()">
              <span>üîç</span> Fit All
            </button>
          </div>
        </div>
      </div>

      <!-- NEW: Map Export Section -->
      <div class="card" id="map-export" style="display: none;">
        <div class="card-header" onclick="RouteFinderApp.ui.toggleSection('map-export')">
          <div style="display: flex; align-items: center;">
            <span class="icon">üì∏</span>
            <span>Map Export</span>
          </div>
          <span class="chevron">‚ñ∑</span>
        </div>
        <div class="card-content collapsible" id="map-export-content">
          <div style="margin-bottom: var(--space-4); padding: var(--space-3); background: var(--color-surface-secondary); border-radius: var(--border-radius-md); font-size: var(--font-size-sm); color: var(--color-text-secondary);">
            Export your map as a high-resolution image for printing or sharing.
          </div>
          
          <button class="btn btn-primary btn-full" onclick="RouteFinderApp.mapExport.showExportDialog()" title="Export map as high-resolution image">
            <span>üì∏</span> Export Map Image
          </button>
          
          <div style="margin-top: var(--space-3); font-size: var(--font-size-xs); color: var(--color-text-tertiary); text-align: center;">
            Keyboard shortcut: Ctrl+E
          </div>
        </div>
      </div>

      <!-- Initialize Application Controls -->
      <div class="card" id="init-controls">
        <div class="card-header">
          <div style="display: flex; align-items: center;">
            <span class="icon">‚óØ</span>
            <span>Initialize Application</span>
          </div>
        </div>
        <div class="card-content">
          <button class="btn btn-primary btn-full" onclick="RouteFinderApp.init()" id="init-app-btn">
            ‚Üí Start Route Finder
          </button>
          <p style="font-size: var(--font-size-xs); color: var(--color-text-tertiary); margin: var(--space-3) 0 0 0; text-align: center;">
            This will load the mapping libraries and start the full application.
          </p>
        </div>
      </div>
    </div>
  </div>

  <!-- Map Container -->
  <div id="map"></div>

  <!-- Hidden file input for import -->
  <input type="file" id="file-input" accept=".json" style="display: none;" onchange="RouteFinderApp.fileManager.handleFileImport(event)">

  <!-- Map Export Dialog -->
  <div id="export-dialog" class="export-dialog">
    <div class="export-dialog-backdrop" onclick="RouteFinderApp.mapExport.hideExportDialog()"></div>
    <div class="export-dialog-content">
      <div class="export-dialog-header">
        <h3>
          <span>üì∏</span>
          Export Map
        </h3>
        <button class="btn-close" onclick="RouteFinderApp.mapExport.hideExportDialog()">
          <span>‚úï</span>
        </button>
      </div>
      
      <div class="export-dialog-body">
        <div class="export-form">
          <!-- Format Section -->
          <div class="form-section">
            <h4>üé® Format & Quality</h4>
            <div class="form-grid">
              <div class="form-group">
                <label class="form-label">File Format</label>
                <select id="export-format" class="form-select" onchange="RouteFinderApp.mapExport.updatePreview()">
                  <option value="png">PNG (Lossless)</option>
                  <option value="jpeg">JPEG (Compressed)</option>
                </select>
              </div>
              <div class="form-group">
                <label class="form-label">DPI Resolution</label>
                <select id="export-dpi" class="form-select" onchange="RouteFinderApp.mapExport.updatePreview()">
                  <option value="150">150 DPI (Web)</option>
                  <option value="300">300 DPI (Print)</option>
                  <option value="600">600 DPI (High Print)</option>
                </select>
              </div>
            </div>
          </div>

          <!-- Size Section -->
          <div class="form-section">
            <h4>üìè Print Size</h4>
            <div class="form-group">
              <label class="form-label">Standard Sizes</label>
              <select id="export-size" class="form-select" onchange="RouteFinderApp.mapExport.updateSizeControls()">
                <!-- Photo Sizes -->
                <optgroup label="üì∑ Photo Sizes">
                  <option value="4x6">4√ó6" (Postcard)</option>
                  <option value="5x7">5√ó7" (Photo)</option>
                  <option value="8x10">8√ó10" (Photo)</option>
                  <option value="11x14">11√ó14" (Photo)</option>
                </optgroup>
                <!-- Document Sizes -->
                <optgroup label="üìÑ Document Sizes">
                  <option value="letter">8.5√ó11" (Letter)</option>
                  <option value="legal">8.5√ó14" (Legal)</option>
                  <option value="tabloid">11√ó17" (Tabloid)</option>
                </optgroup>
                <!-- A-Series -->
                <optgroup label="üåç A-Series (ISO)">
                  <option value="a4">A4 (8.3√ó11.7")</option>
                  <option value="a3">A3 (11.7√ó16.5")</option>
                  <option value="a2">A2 (16.5√ó23.4")</option>
                  <option value="a1">A1 (23.4√ó33.1")</option>
                  <option value="a0">A0 (33.1√ó46.8")</option>
                </optgroup>
                <!-- Large Format -->
                <optgroup label="üñº Large Format">
                  <option value="18x24">18√ó24" (Poster)</option>
                  <option value="24x36">24√ó36" (Large Poster)</option>
                  <option value="30x40">30√ó40" (Gallery)</option>
                </optgroup>
                <!-- Custom -->
                <option value="custom">Custom Size</option>
              </select>
            </div>
            
            <div id="custom-size-controls" class="custom-size-controls" style="display: none;">
              <div class="form-grid">
                <div class="form-group">
                  <label class="form-label">Width (inches)</label>
                  <input type="number" id="custom-width" class="form-input" value="8.5" min="1" max="100" step="0.1" onchange="RouteFinderApp.mapExport.updatePreview()">
                </div>
                <div class="form-group">
                  <label class="form-label">Height (inches)</label>
                  <input type="number" id="custom-height" class="form-input" value="11" min="1" max="100" step="0.1" onchange="RouteFinderApp.mapExport.updatePreview()">
                </div>
              </div>
            </div>
          </div>

          <!-- Advanced Options -->
          <div class="form-section">
            <h4>‚öôÔ∏è Advanced Options</h4>
            <label class="form-checkbox">
              <input type="checkbox" id="export-bleed">
              <span class="checkmark"></span>
              Add 0.125" bleed margin for professional printing
            </label>
          </div>
        </div>

        <!-- Preview Section -->
        <div class="export-preview-section">
          <h4>üîç Export Preview</h4>
          <div class="export-preview">
            <div class="preview-item">
              <span class="preview-label">Dimensions:</span>
              <span class="preview-value" id="preview-dimensions">8.5√ó11"</span>
            </div>
            <div class="preview-item">
              <span class="preview-label">Resolution:</span>
              <span class="preview-value" id="preview-resolution">2550√ó3300 px</span>
            </div>
            <div class="preview-item">
              <span class="preview-label">File Size:</span>
              <span class="preview-value" id="preview-filesize">~25 MB</span>
            </div>
            <div class="preview-item">
              <span class="preview-label">DPI:</span>
              <span class="preview-value" id="preview-dpi">300</span>
            </div>
          </div>
          
          <div class="text-muted text-center" style="margin-top: var(--space-4);">
            Export will capture the current map view including zoom level, center point, and style.
          </div>
        </div>
      </div>
      
      <div class="export-dialog-footer">
        <button class="btn btn-secondary" onclick="RouteFinderApp.mapExport.hideExportDialog()">
          Cancel
        </button>
        <button class="btn btn-primary" onclick="RouteFinderApp.mapExport.exportMap()" id="export-btn">
          <span>üì∏</span>
          Export Map
        </button>
      </div>
    </div>
  </div>

  <script>
    // ===== MAP EXPORT MODULE =====
    // Professional map export functionality with high-resolution output

    const MapExportManager = {
      // Print size definitions in inches
      printSizes: {
        '4x6': { width: 4, height: 6 },
        '5x7': { width: 5, height: 7 },
        '8x10': { width: 8, height: 10 },
        '11x14': { width: 11, height: 14 },
        'letter': { width: 8.5, height: 11 },
        'legal': { width: 8.5, height: 14 },
        'tabloid': { width: 11, height: 17 },
        'a4': { width: 8.27, height: 11.69 },
        'a3': { width: 11.69, height: 16.54 },
        'a2': { width: 16.54, height: 23.39 },
        'a1': { width: 23.39, height: 33.11 },
        'a0': { width: 33.11, height: 46.81 },
        '18x24': { width: 18, height: 24 },
        '24x36': { width: 24, height: 36 },
        '30x40': { width: 30, height: 40 }
      },

      // Initialize the export manager
      init() {
        this.updatePreview();
      },

      // Show the export dialog
      showExportDialog() {
        const dialog = document.getElementById('export-dialog');
        dialog.style.display = 'flex';
        this.updatePreview();
      },

      // Hide the export dialog
      hideExportDialog() {
        const dialog = document.getElementById('export-dialog');
        dialog.style.display = 'none';
      },

      // Update size controls based on selection
      updateSizeControls() {
        const sizeSelect = document.getElementById('export-size');
        const customControls = document.getElementById('custom-size-controls');
        
        if (sizeSelect.value === 'custom') {
          customControls.style.display = 'block';
        } else {
          customControls.style.display = 'none';
        }
        
        this.updatePreview();
      },

      // Get current dimensions based on selection
      getCurrentDimensions() {
        const sizeSelect = document.getElementById('export-size');
        const bleedCheckbox = document.getElementById('export-bleed');
        
        let dimensions;
        
        if (sizeSelect.value === 'custom') {
          const width = parseFloat(document.getElementById('custom-width').value) || 8.5;
          const height = parseFloat(document.getElementById('custom-height').value) || 11;
          dimensions = { width, height };
        } else {
          dimensions = this.printSizes[sizeSelect.value] || this.printSizes.letter;
        }
        
        // Add bleed if selected
        if (bleedCheckbox.checked) {
          dimensions.width += 0.25; // 0.125" on each side
          dimensions.height += 0.25;
        }
        
        return dimensions;
      },

      // Update the live preview
      updatePreview() {
        const dimensions = this.getCurrentDimensions();
        const dpi = parseInt(document.getElementById('export-dpi').value);
        const format = document.getElementById('export-format').value;
        
        // Calculate pixel dimensions
        const pixelWidth = Math.round(dimensions.width * dpi);
        const pixelHeight = Math.round(dimensions.height * dpi);
        
        // Estimate file size (rough calculation)
        const totalPixels = pixelWidth * pixelHeight;
        let estimatedSize;
        
        if (format === 'png') {
          estimatedSize = totalPixels * 3; // 3 bytes per pixel for PNG
        } else {
          estimatedSize = totalPixels * 0.5; // JPEG compression
        }
        
        // Update preview display
        document.getElementById('preview-dimensions').textContent = 
          `${dimensions.width.toFixed(1)}√ó${dimensions.height.toFixed(1)}"`;
        document.getElementById('preview-resolution').textContent = 
          `${pixelWidth}√ó${pixelHeight} px`;
        document.getElementById('preview-dpi').textContent = dpi;
        document.getElementById('preview-filesize').textContent = 
          this.formatFileSize(estimatedSize);
      },

      // Format file size for display
      formatFileSize(bytes) {
        if (bytes >= 1024 * 1024) {
          return `~${(bytes / (1024 * 1024)).toFixed(1)} MB`;
        } else if (bytes >= 1024) {
          return `~${(bytes / 1024).toFixed(1)} KB`;
        } else {
          return `~${bytes} bytes`;
        }
      },

      // Export the map with current settings
      async exportMap() {
        try {
          // Get export settings
          const dimensions = this.getCurrentDimensions();
          const dpi = parseInt(document.getElementById('export-dpi').value);
          const format = document.getElementById('export-format').value;
          
          // Calculate pixel dimensions
          const pixelWidth = Math.round(dimensions.width * dpi);
          const pixelHeight = Math.round(dimensions.height * dpi);
          
          // Show loading state
          const exportBtn = document.getElementById('export-btn');
          const originalText = exportBtn.innerHTML;
          exportBtn.innerHTML = '<span>‚è≥</span> Exporting...';
          exportBtn.disabled = true;
          
          // Update status
          if (window.RouteFinderApp && window.RouteFinderApp.ui) {
            window.RouteFinderApp.ui.updateStatus('üîÑ Generating high-resolution map export...', 'loading');
          }
          
          // Get the map instance
          const map = window.State?.map;
          if (!map) {
            throw new Error('Map not available');
          }
          
          // Wait for map to be fully loaded
          await new Promise(resolve => {
            if (map.loaded()) {
              resolve();
            } else {
              map.on('load', resolve);
            }
          });
          
          // Create canvas for export
          const canvas = document.createElement('canvas');
          canvas.width = pixelWidth;
          canvas.height = pixelHeight;
          const ctx = canvas.getContext('2d');
          
          // Get map canvas
          const mapCanvas = map.getCanvas();
          
          // Scale and draw the map
          ctx.drawImage(mapCanvas, 0, 0, pixelWidth, pixelHeight);
          
          // Convert to blob
          const blob = await new Promise(resolve => {
            canvas.toBlob(resolve, `image/${format}`, format === 'jpeg' ? 0.9 : undefined);
          });
          
          // Create download
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `map-export-${dimensions.width}x${dimensions.height}-${dpi}dpi.${format}`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          
          // Success feedback
          if (window.RouteFinderApp && window.RouteFinderApp.ui) {
            window.RouteFinderApp.ui.updateStatus('‚úÖ Map exported successfully!', 'success');
          }
          
          // Hide dialog
          this.hideExportDialog();
          
        } catch (error) {
          console.error('Export failed:', error);
          
          // Error feedback
          if (window.RouteFinderApp && window.RouteFinderApp.ui) {
            window.RouteFinderApp.ui.updateStatus('‚ùå Export failed: ' + error.message, 'error');
          }
        } finally {
          // Restore button
          const exportBtn = document.getElementById('export-btn');
          exportBtn.innerHTML = originalText;
          exportBtn.disabled = false;
        }
      }
    };

    // Main Application Object with Modular Architecture
    const RouteFinderApp = (function() {
      'use strict';

      // Configuration Object - Centralized Settings
      const Config = {
        // Map Configuration
        mapbox: {
          accessToken: 'pk.eyJ1IjoiY2IyOSIsImEiOiJja3E4OHo3anowZGx1Mm9tcXF3ZmhyaWtwIn0.IQ5rY622AU9GOETrqa9NBw',
          defaultStyle: 'mapbox://styles/mapbox/streets-v11',
          defaultCenter: [-74.006, 40.7128], // NYC
          defaultZoom: 11
        },
        
        // Routing Configuration  
        routing: {
          profile: 'driving', // driving, walking, cycling
          alternatives: false,
          geometries: 'geojson',
          overview: 'full',
          steps: true
        },
        
        // UI Configuration
        ui: {
          sidebarWidth: 380,
          animationDuration: 200,
          statusDisplayTime: 3000
        }
      };

      // Global State Management
      const State = {
        map: null,
        routes: new Map(),
        currentRouteId: null,
        routeCounter: 1,
        interactions: {
          addingWaypoint: false,
          pickingOrigin: false,
          pickingDestination: false
        },
        ui: {
          sidebarVisible: true,
          sectionsCollapsed: new Set()
        },

        // Route Management Methods
        createRoute(name = null) {
          const id = this.routeCounter++;
          const route = {
            id: id,
            name: name || `Route ${id}`,
            origin: null,
            destination: null,
            waypoints: [],
            routeData: null,
            visible: true,
            color: this.generateRouteColor(id)
          };
          this.routes.set(id, route);
          this.currentRouteId = id;
          return route;
        },

        getCurrentRoute() {
          return this.routes.get(this.currentRouteId);
        },

        generateRouteColor(id) {
          const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4', '#84cc16', '#f97316'];
          return colors[(id - 1) % colors.length];
        }
      };

      // Event System for Loose Coupling
      const EventSystem = {
        listeners: new Map(),

        on(event, callback) {
          if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
          }
          this.listeners.get(event).push(callback);
        },

        emit(event, data) {
          const callbacks = this.listeners.get(event) || [];
          callbacks.forEach(callback => callback(data));
        }
      };

      // Utility Functions
      const Utils = {
        debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        },

        updateStatus(message, type = 'info') {
          const statusEl = document.getElementById('status-message');
          if (!statusEl) return;

          statusEl.innerHTML = message;
          statusEl.className = `status-message status-${type}`;
          
          if (type === 'success' || type === 'error') {
            setTimeout(() => {
              Utils.updateStatus('<strong>üéâ Ready!</strong><br>Multi-route mapper is ready to use', 'success');
            }, Config.ui.statusDisplayTime);
          }

          EventSystem.emit('statusUpdated', { message, type });
        },

        formatDistance(meters) {
          if (meters >= 1000) {
            return `${(meters / 1000).toFixed(1)} km`;
          }
          return `${Math.round(meters)} m`;
        },

        formatDuration(seconds) {
          const hours = Math.floor(seconds / 3600);
          const minutes = Math.floor((seconds % 3600) / 60);
          
          if (hours > 0) {
            return `${hours}h ${minutes}m`;
          }
          return `${minutes}m`;
        }
      };

      // Map Management Module
      const MapManager = {
        async initialize() {
          try {
            mapboxgl.accessToken = Config.mapbox.accessToken;
            
            State.map = new mapboxgl.Map({
              container: 'map',
              style: Config.mapbox.defaultStyle,
              center: Config.mapbox.defaultCenter,
              zoom: Config.mapbox.defaultZoom,
              preserveDrawingBuffer: true // Important for export functionality
            });

            // Wait for map to load
            await new Promise(resolve => State.map.on('load', resolve));
            
            // Setup map event listeners
            this.setupEventListeners();
            
            Utils.updateStatus('<strong>‚úÖ Map Loaded!</strong><br>Click to set origin and destination', 'success');
            EventSystem.emit('mapInitialized', State.map);
            
          } catch (error) {
            console.error('Map initialization failed:', error);
            Utils.updateStatus('<strong>‚ùå Map Failed</strong><br>Check your internet connection', 'error');
            throw error;
          }
        },

        setupEventListeners() {
          // Map click handling for location selection
          State.map.on('click', (e) => {
            this.handleMapClick(e.lngLat);
          });

          // Map style change handling
          State.map.on('style.load', () => {
            // Re-add all route sources and layers after style change
            RouteRenderer.redrawAllRoutes();
          });
        },

        handleMapClick(lngLat) {
          const route = State.getCurrentRoute();
          if (!route) return;

          if (State.interactions.pickingOrigin || (!route.origin && !State.interactions.addingWaypoint)) {
            this.setOrigin(lngLat);
          } else if (State.interactions.pickingDestination || (!route.destination && !State.interactions.addingWaypoint)) {
            this.setDestination(lngLat);
          } else if (State.interactions.addingWaypoint) {
            this.addWaypoint(lngLat);
          }
        },

        async setOrigin(lngLat) {
          const route = State.getCurrentRoute();
          if (!route) return;

          route.origin = lngLat;
          State.interactions.pickingOrigin = false;
          
          const address = await this.reverseGeocode(lngLat);
          document.getElementById('origin-input').value = address;
          
          RouteRenderer.updateMarkers();
          Utils.updateStatus('<strong>üìç Origin Set!</strong><br>Now set your destination', 'success');
          EventSystem.emit('originSet', { route, lngLat, address });
        },

        async setDestination(lngLat) {
          const route = State.getCurrentRoute();
          if (!route) return;

          route.destination = lngLat;
          State.interactions.pickingDestination = false;
          
          const address = await this.reverseGeocode(lngLat);
          document.getElementById('destination-input').value = address;
          
          RouteRenderer.updateMarkers();
          Utils.updateStatus('<strong>üéØ Destination Set!</strong><br>Ready to find route', 'success');
          EventSystem.emit('destinationSet', { route, lngLat, address });
        },

        async addWaypoint(lngLat) {
          const route = State.getCurrentRoute();
          if (!route) return;

          const address = await this.reverseGeocode(lngLat);
          route.waypoints.push({ lngLat, address });
          
          RouteRenderer.updateMarkers();
          UIManager.updateWaypointsList();
          Utils.updateStatus('<strong>üìå Waypoint Added!</strong><br>Click map for more or find route', 'success');
          EventSystem.emit('waypointAdded', { route, lngLat, address });
        },

        async reverseGeocode(lngLat) {
          try {
            const response = await fetch(
              `https://api.mapbox.com/geocoding/v5/mapbox.places/${lngLat.lng},${lngLat.lat}.json?access_token=${Config.mapbox.accessToken}`
            );
            const data = await response.json();
            return data.features[0]?.place_name || `${lngLat.lat.toFixed(4)}, ${lngLat.lng.toFixed(4)}`;
          } catch (error) {
            console.error('Reverse geocoding failed:', error);
            return `${lngLat.lat.toFixed(4)}, ${lngLat.lng.toFixed(4)}`;
          }
        }
      };

      // Route Rendering Module
      const RouteRenderer = {
        updateMarkers() {
          const route = State.getCurrentRoute();
          if (!route) return;

          // Clear existing markers
          this.clearMarkers();

          // Add origin marker
          if (route.origin) {
            this.addMarker(route.origin, 'origin', 'üìç');
          }

          // Add destination marker
          if (route.destination) {
            this.addMarker(route.destination, 'destination', 'üéØ');
          }

          // Add waypoint markers
          route.waypoints.forEach((waypoint, index) => {
            this.addMarker(waypoint.lngLat, `waypoint-${index}`, 'üìå');
          });
        },

        addMarker(lngLat, id, emoji) {
          const el = document.createElement('div');
          el.className = 'marker';
          el.innerHTML = emoji;
          el.style.cssText = `
            background: white;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
          `;

          new mapboxgl.Marker(el)
            .setLngLat(lngLat)
            .addTo(State.map);
        },

        clearMarkers() {
          const markers = document.querySelectorAll('.marker');
          markers.forEach(marker => {
            const parent = marker.parentElement;
            if (parent) parent.remove();
          });
        },

        displayRoute(routeData) {
          const route = State.getCurrentRoute();
          if (!route) return;

          const sourceId = `route-${route.id}`;
          const layerId = `route-layer-${route.id}`;

          // Remove existing route if it exists
          if (State.map.getSource(sourceId)) {
            State.map.removeLayer(layerId);
            State.map.removeSource(sourceId);
          }

          // Add new route
          State.map.addSource(sourceId, {
            type: 'geojson',
            data: {
              type: 'Feature',
              properties: {},
              geometry: routeData.geometry
            }
          });

          State.map.addLayer({
            id: layerId,
            type: 'line',
            source: sourceId,
            layout: {
              'line-join': 'round',
              'line-cap': 'round'
            },
            paint: {
              'line-color': route.color,
              'line-width': 4,
              'line-opacity': route.visible ? 0.8 : 0.3
            }
          });

          // Store route data
          route.routeData = routeData;

          // Update UI with route info
          this.updateRouteInfo(routeData);
        },

        updateRouteInfo(routeData) {
          const distance = Utils.formatDistance(routeData.distance);
          const duration = Utils.formatDuration(routeData.duration);
          
          Utils.updateStatus(
            `<strong>‚úÖ Route Found!</strong><br>Distance: ${distance} ‚Ä¢ Time: ${duration}`,
            'success'
          );
        },

        redrawAllRoutes() {
          State.routes.forEach(route => {
            if (route.routeData) {
              this.displayRoute(route.routeData);
            }
          });
        },

        toggleRouteVisibility(routeId) {
          const route = State.routes.get(routeId);
          if (!route) return;

          route.visible = !route.visible;
          
          const layerId = `route-layer-${routeId}`;
          if (State.map.getLayer(layerId)) {
            State.map.setPaintProperty(layerId, 'line-opacity', route.visible ? 0.8 : 0.3);
          }
          
          UIManager.updateRoutesList();
        }
      };

      // Interaction Management
      const InteractionManager = {
        toggleWaypointMode() {
          State.interactions.addingWaypoint = !State.interactions.addingWaypoint;
          
          const crosshair = document.getElementById('map-crosshair');
          const toggleBtn = document.getElementById('waypoint-toggle-btn');
          
          if (State.interactions.addingWaypoint) {
            crosshair.style.display = 'block';
            toggleBtn.innerHTML = '<span>‚úï</span> Cancel Waypoint';
            toggleBtn.classList.remove('btn-secondary');
            toggleBtn.classList.add('btn-primary');
            Utils.updateStatus('<strong>üìå Waypoint Mode</strong><br>Click map to add waypoints', 'info');
          } else {
            crosshair.style.display = 'none';
            toggleBtn.innerHTML = '<span>+</span> Add Waypoint';
            toggleBtn.classList.remove('btn-primary');
            toggleBtn.classList.add('btn-secondary');
            Utils.updateStatus('<strong>üéâ Ready!</strong><br>Multi-route mapper is ready to use', 'success');
          }

          EventSystem.emit('waypointModeToggled', State.interactions.addingWaypoint);
        }
      };

      // Routing Module
      const RoutingManager = {
        async findRoute() {
          const route = State.getCurrentRoute();
          if (!route || !route.origin || !route.destination) {
            Utils.updateStatus('<strong>‚ùå Missing Data</strong><br>Need both origin and destination', 'error');
            return;
          }
          
          Utils.updateStatus('<strong>üîÑ Finding Route...</strong><br>Calculating best path', 'loading');
          
          try {
            const coordinates = [route.origin];
            coordinates.push(...route.waypoints.map(w => w.lngLat));
            coordinates.push(route.destination);
            
            const coordString = coordinates
              .map(coord => `${coord.lng},${coord.lat}`)
              .join(';');
            
            const travelMode = document.getElementById('travel-mode').value;
            const url = `https://api.mapbox.com/directions/v5/mapbox/${travelMode}/${coordString}?` +
              `geometries=geojson&overview=full&steps=true&access_token=${Config.mapbox.accessToken}`;
            
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.routes && data.routes.length > 0) {
              RouteRenderer.displayRoute(data.routes[0]);
              EventSystem.emit('routeCalculated', { route, routeData: data.routes[0] });
            } else {
              throw new Error('No route found');
            }
            
          } catch (error) {
            console.error('Routing failed:', error);
            Utils.updateStatus('<strong>‚ùå Route Failed</strong><br>Could not calculate route', 'error');
          }
        }
      };

      // Route Management System
      const RouteManager = {
        createNewRoute() {
          const route = State.createRoute();
          UIManager.updateRouteTabs();
          UIManager.switchToRoute(route.id);
          Utils.updateStatus('<strong>‚ûï New Route Created</strong><br>Set origin and destination', 'info');
          EventSystem.emit('routeCreated', route);
        },

        switchToRoute(routeId) {
          const route = State.routes.get(routeId);
          if (!route) return;

          State.currentRouteId = routeId;
          
          // Update UI
          UIManager.updateRouteTabs();
          UIManager.populateRouteInputs(route);
          RouteRenderer.updateMarkers();
          
          // Update current route panel title
          const title = document.getElementById('current-route-title');
          if (title) {
            title.textContent = `Current Route: ${route.name}`;
          }
          
          Utils.updateStatus(`<strong>üìã Switched to ${route.name}</strong><br>Edit origin, destination, or waypoints`, 'info');
          EventSystem.emit('routeSwitched', route);
        },

        deleteRoute(routeId) {
          if (State.routes.size <= 1) {
            Utils.updateStatus('<strong>‚ö†Ô∏è Cannot Delete</strong><br>Must keep at least one route', 'error');
            return;
          }

          const route = State.routes.get(routeId);
          if (!route) return;

          // Remove route from map
          const sourceId = `route-${routeId}`;
          const layerId = `route-layer-${routeId}`;
          
          if (State.map.getSource(sourceId)) {
            State.map.removeLayer(layerId);
            State.map.removeSource(sourceId);
          }

          // Remove from state
          State.routes.delete(routeId);

          // Switch to another route if current was deleted
          if (State.currentRouteId === routeId) {
            const remainingRouteId = State.routes.keys().next().value;
            this.switchToRoute(remainingRouteId);
          }

          UIManager.updateRouteTabs();
          UIManager.updateRoutesList();
          
          Utils.updateStatus(`<strong>üóë Route Deleted</strong><br>${route.name} has been removed`, 'success');
          EventSystem.emit('routeDeleted', { routeId, route });
        },

        toggleRouteVisibility(routeId) {
          RouteRenderer.toggleRouteVisibility(routeId);
          EventSystem.emit('routeVisibilityToggled', { routeId });
        }
      };

      // UI Management Module
      const UIManager = {
        toggleSidebar() {
          const sidebar = document.getElementById('sidebar');
          const toggleBtn = document.getElementById('toggle-btn');
          
          State.ui.sidebarVisible = !State.ui.sidebarVisible;
          
          if (State.ui.sidebarVisible) {
            sidebar.classList.remove('hidden');
            toggleBtn.classList.add('sidebar-visible');
          } else {
            sidebar.classList.add('hidden');
            toggleBtn.classList.remove('sidebar-visible');
          }
        },

        toggleSection(sectionId) {
          const content = document.getElementById(sectionId + '-content') || document.getElementById(sectionId);
          const header = content?.previousElementSibling;
          const chevron = header?.querySelector('.chevron');
          
          if (!content) return;
          
          const isCollapsed = State.ui.sectionsCollapsed.has(sectionId);
          
          if (isCollapsed) {
            content.classList.remove('collapsed');
            State.ui.sectionsCollapsed.delete(sectionId);
            if (chevron) chevron.textContent = '‚ñº';
          } else {
            content.classList.add('collapsed');
            State.ui.sectionsCollapsed.add(sectionId);
            if (chevron) chevron.textContent = '‚ñ∑';
          }
        },

        updateRouteTabs() {
          const container = document.getElementById('route-tabs');
          if (!container) return;

          container.innerHTML = '';
          
          State.routes.forEach(route => {
            const tab = document.createElement('div');
            tab.className = `route-tab ${route.id === State.currentRouteId ? 'active' : ''}`;
            tab.innerHTML = `
              <span style="color: ${route.color}">‚óè</span>
              ${route.name}
            `;
            tab.onclick = () => RouteManager.switchToRoute(route.id);
            container.appendChild(tab);
          });
        },

        populateRouteInputs(route) {
          // Update origin input
          const originInput = document.getElementById('origin-input');
          if (route.origin && originInput) {
            MapManager.reverseGeocode(route.origin).then(address => {
              originInput.value = address;
            });
          } else if (originInput) {
            originInput.value = '';
          }

          // Update destination input
          const destInput = document.getElementById('destination-input');
          if (route.destination && destInput) {
            MapManager.reverseGeocode(route.destination).then(address => {
              destInput.value = address;
            });
          } else if (destInput) {
            destInput.value = '';
          }

          // Update waypoints
          this.updateWaypointsList();
        },

        updateWaypointsList() {
          const route = State.getCurrentRoute();
          if (!route) return;
          
          const waypointsList = document.getElementById('waypoint-list');
          
          if (route.waypoints.length === 0) {
            waypointsList.innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); font-size: var(--font-size-sm); padding: var(--space-3);">No waypoints added</div>';
            return;
          }
          
          waypointsList.innerHTML = '';
          
          route.waypoints.forEach((waypoint, index) => {
            const item = document.createElement('div');
            item.className = 'waypoint-item';
            item.innerHTML = `
              <div class="waypoint-content">
                <span style="color: var(--color-text-secondary); font-weight: var(--font-weight-medium);">${index + 1}.</span>
                <span>${waypoint.address}</span>
              </div>
              <button class="btn btn-small" onclick="RouteFinderApp.ui.removeWaypoint(${index})" title="Remove waypoint">‚úï</button>
            `;
            waypointsList.appendChild(item);
          });
        },

        removeWaypoint(index) {
          const route = State.getCurrentRoute();
          if (!route) return;

          route.waypoints.splice(index, 1);
          this.updateWaypointsList();
          RouteRenderer.updateMarkers();
          
          Utils.updateStatus('<strong>üóë Waypoint Removed</strong><br>Waypoint deleted successfully', 'success');
          EventSystem.emit('waypointRemoved', { route, index });
        },

        clearWaypoints() {
          const route = State.getCurrentRoute();
          if (!route) return;

          route.waypoints = [];
          this.updateWaypointsList();
          RouteRenderer.updateMarkers();
          
          Utils.updateStatus('<strong>üóë Waypoints Cleared</strong><br>All waypoints removed', 'success');
          EventSystem.emit('waypointsCleared', route);
        },

        clearCurrentRoute() {
          const route = State.getCurrentRoute();
          if (!route) return;

          // Clear route data
          route.origin = null;
          route.destination = null;
          route.waypoints = [];
          route.routeData = null;

          // Clear UI
          document.getElementById('origin-input').value = '';
          document.getElementById('destination-input').value = '';
          this.updateWaypointsList();

          // Clear map
          RouteRenderer.clearMarkers();
          
          const sourceId = `route-${route.id}`;
          const layerId = `route-layer-${route.id}`;
          
          if (State.map.getSource(sourceId)) {
            State.map.removeLayer(layerId);
            State.map.removeSource(sourceId);
          }

          Utils.updateStatus('<strong>üóë Route Cleared</strong><br>Ready for new route', 'success');
          EventSystem.emit('routeCleared', route);
        },

        changeMapStyle() {
          const styleSelect = document.getElementById('map-style');
          const newStyle = styleSelect.value;
          
          State.map.setStyle(newStyle);
          Utils.updateStatus('<strong>üé® Style Changed</strong><br>Map appearance updated', 'success');
          EventSystem.emit('mapStyleChanged', newStyle);
        },

        zoomToUserLocation() {
          if (!navigator.geolocation) {
            Utils.updateStatus('<strong>‚ùå Location Unavailable</strong><br>Geolocation not supported', 'error');
            return;
          }

          Utils.updateStatus('<strong>üîÑ Getting Location...</strong><br>Requesting your position', 'loading');
          
          navigator.geolocation.getCurrentPosition(
            (position) => {
              const { latitude, longitude } = position.coords;
              State.map.flyTo({
                center: [longitude, latitude],
                zoom: 14
              });
              Utils.updateStatus('<strong>üìç Location Found!</strong><br>Centered on your position', 'success');
            },
            (error) => {
              console.error('Geolocation error:', error);
              Utils.updateStatus('<strong>‚ùå Location Failed</strong><br>Could not get your position', 'error');
            }
          );
        },

        fitMapToRoutes() {
          const visibleRoutes = Array.from(State.routes.values()).filter(route => route.visible && route.routeData);
          
          if (visibleRoutes.length === 0) {
            Utils.updateStatus('<strong>‚ÑπÔ∏è No Routes</strong><br>No visible routes to fit', 'info');
            return;
          }

          const bounds = new mapboxgl.LngLatBounds();
          
          visibleRoutes.forEach(route => {
            route.routeData.geometry.coordinates.forEach(coord => {
              bounds.extend(coord);
            });
          });

          State.map.fitBounds(bounds, { padding: 50 });
          Utils.updateStatus('<strong>üîç Fitted to Routes</strong><br>All routes now visible', 'success');
        },

        toggleRouteList() {
          const routeList = document.getElementById('route-list');
          const toggleBtn = document.getElementById('route-list-toggle');
          
          if (routeList.style.display === 'none') {
            this.updateRoutesList();
            routeList.style.display = 'block';
            toggleBtn.textContent = '‚ñ≤ Hide Routes';
          } else {
            routeList.style.display = 'none';
            toggleBtn.textContent = '‚ãØ Show All Routes';
          }
        },

        updateRoutesList() {
          const container = document.getElementById('route-list');
          if (!container) return;

          container.innerHTML = '';
          
          State.routes.forEach(route => {
            const item = document.createElement('div');
            item.className = 'route-list-item';
            item.innerHTML = `
              <div class="route-name">
                <span style="color: ${route.color}; margin-right: var(--space-2);">‚óè</span>
                ${route.name}
              </div>
              <div class="route-actions">
                <button class="btn btn-small ${route.visible ? '' : 'opacity: 0.5'}" 
                        style="opacity: ${route.visible ? '1' : '0.5'}" 
                        onclick="RouteFinderApp.routes.toggleRouteVisibility(${route.id})" 
                        title="Toggle visibility">
                  ${route.visible ? '‚óâ' : '‚óã'}
                </button>
                <button class="btn btn-small" onclick="RouteFinderApp.routes.switchToRoute(${route.id})" title="Edit route">‚úé</button>
                <button class="btn btn-small" onclick="RouteFinderApp.routes.deleteRoute(${route.id})" title="Delete route">‚úï</button>
              </div>
            `;
            container.appendChild(item);
          });
        },

        showRoutesListIfNeeded() {
          if (State.routes.size > 3) {
            const toggleBtn = document.getElementById('route-list-toggle');
            if (toggleBtn) {
              toggleBtn.style.display = 'block';
            }
          }
        }
      };

      // File Management Module
      const FileManager = {
        exportRoutes() {
          const routesData = {
            routes: Array.from(State.routes.values()).map(route => ({
              id: route.id,
              name: route.name,
              origin: route.origin,
              destination: route.destination,
              waypoints: route.waypoints,
              color: route.color,
              visible: route.visible
            })),
            exportDate: new Date().toISOString(),
            version: '1.0'
          };

          const dataStr = JSON.stringify(routesData, null, 2);
          const dataBlob = new Blob([dataStr], { type: 'application/json' });
          
          const link = document.createElement('a');
          link.href = URL.createObjectURL(dataBlob);
          link.download = `routes-export-${new Date().toISOString().slice(0, 10)}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          Utils.updateStatus('<strong>üì§ Routes Exported</strong><br>File downloaded successfully', 'success');
          EventSystem.emit('routesExported', routesData);
        },

        triggerImportRoutes() {
          const fileInput = document.getElementById('file-input');
          fileInput.click();
        },

        async handleFileImport(event) {
          const file = event.target.files[0];
          if (!file) return;

          try {
            const text = await file.text();
            const data = JSON.parse(text);
            
            if (!data.routes || !Array.isArray(data.routes)) {
              throw new Error('Invalid file format');
            }

            // Clear existing routes
            State.routes.clear();
            
            // Import routes
            data.routes.forEach(routeData => {
              const route = State.createRoute(routeData.name);
              route.origin = routeData.origin;
              route.destination = routeData.destination;
              route.waypoints = routeData.waypoints || [];
              route.color = routeData.color;
              route.visible = routeData.visible !== false;
              
              // Set highest ID to avoid conflicts
              if (routeData.id >= State.routeCounter) {
                State.routeCounter = routeData.id + 1;
              }
            });

            // Switch to first route
            const firstRouteId = State.routes.keys().next().value;
            if (firstRouteId) {
              RouteManager.switchToRoute(firstRouteId);
            }

            // Update UI
            UIManager.updateRouteTabs();
            UIManager.updateRoutesList();
            UIManager.showRoutesListIfNeeded();
            RouteRenderer.updateMarkers();
            
            Utils.updateStatus(`<strong>üì• Routes Imported</strong><br>Loaded ${data.routes.length} routes`, 'success');
            EventSystem.emit('routesImported', data);
            
          } catch (error) {
            console.error('Import failed:', error);
            Utils.updateStatus('<strong>‚ùå Import Failed</strong><br>Invalid file format', 'error');
          }
          
          // Reset file input
          event.target.value = '';
        }
      };

      // Public API
      return {
        // Core initialization
        async init() {
          try {
            Utils.updateStatus('<strong>üîÑ Initializing...</strong><br>Loading mapping services', 'loading');
            
            // Initialize map
            await MapManager.initialize();
            
            // Create initial route
            const initialRoute = State.createRoute();
            
            // Setup UI
            this.showMainInterface();
            UIManager.updateRouteTabs();
            
            // Setup event listeners
            this.setupEventListeners();
            
            Utils.updateStatus('<strong>üéâ Ready!</strong><br>Multi-route mapper is ready to use', 'success');
            
          } catch (error) {
            console.error('Initialization failed:', error);
            Utils.updateStatus('<strong>‚ùå Initialization Failed</strong><br>Please refresh and try again', 'error');
          }
        },

        showMainInterface() {
          // Hide initialization controls
          document.getElementById('init-controls').style.display = 'none';
          
          // Show main interface
          document.getElementById('route-management').style.display = 'block';
          document.getElementById('current-route-panel').style.display = 'block';
          document.getElementById('map-controls').style.display = 'block';
          document.getElementById('map-export').style.display = 'block'; // Show Map Export section
        },

        setupEventListeners() {
          // Route list visibility management
          EventSystem.on('routeCreated', () => {
            UIManager.showRoutesListIfNeeded();
          });

          // Auto-expand sections
          EventSystem.on('mapInitialized', () => {
            // Auto-expand current route section
            if (State.ui.sectionsCollapsed.has('current-route')) {
              UIManager.toggleSection('current-route');
            }
          });
        },

        // Module access
        get map() { return State.map; },
        get state() { return State; },
        get config() { return Config; },
        
        // Public modules
        ui: UIManager,
        routing: RoutingManager,
        routes: RouteManager,
        interactions: InteractionManager,
        fileManager: FileManager,
        utils: Utils
      };
    })();

    // ===== MAP EXPORT INTEGRATION =====
    // Integrates Map Export functionality with Route Finder App

    (function() {
      'use strict';

      // Wait for RouteFinderApp to be available
      function initMapExport() {
        if (typeof RouteFinderApp === 'undefined' || typeof MapExportManager === 'undefined') {
          setTimeout(initMapExport, 100);
          return;
        }

        // Initialize the Map Export Manager
        MapExportManager.init();

        // Add Map Export to the RouteFinderApp namespace
        RouteFinderApp.mapExport = {
          showExportDialog: MapExportManager.showExportDialog.bind(MapExportManager),
          hideExportDialog: MapExportManager.hideExportDialog.bind(MapExportManager),
          exportMap: MapExportManager.exportMap.bind(MapExportManager),
          updatePreview: MapExportManager.updatePreview.bind(MapExportManager),
          updateSizeControls: MapExportManager.updateSizeControls.bind(MapExportManager),
          
          // Additional helper methods
          isAvailable() {
            return typeof MapExportManager !== 'undefined' && 
                   window.State && 
                   window.State.map;
          },
          
          getMapInstance() {
            return window.State?.map;
          }
        };

        // Add event listener for keyboard shortcut (Ctrl+E for Export)
        document.addEventListener('keydown', function(e) {
          if (e.ctrlKey && e.key === 'e' && !e.shiftKey) {
            e.preventDefault();
            if (RouteFinderApp.mapExport.isAvailable()) {
              RouteFinderApp.mapExport.showExportDialog();
            }
          }
        });

        console.log('Map Export functionality integrated successfully');
      }

      // Start initialization
      initMapExport();
    })();

    // Initialize when page loads
    window.addEventListener('load', function() {
      console.log('Page loaded, ready for initialization');
    });
  </script>
</body>
</html> 
            
