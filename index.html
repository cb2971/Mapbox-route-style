<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Route Finder with Multiple Routes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <style type="text/css">
    body {
      margin: 0;
      padding: 0;
      font-family: 'Open Sans', sans-serif;
      background-color: #f0f0f0;
    }
     
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }
     
    .sidebar {
      position: absolute;
      margin: 20px 20px 30px 20px;
      width: 15%;
      min-width: 320px;
      max-height: calc(100vh - 100px);
      top: 0;
      padding: 20px;
      background-color: #fff;
      overflow-y: auto;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      border-radius: 5px;
      z-index: 1000;
      transition: transform 0.3s ease;
    }

    .sidebar.hidden {
      transform: translateX(-100%);
    }

    .toggle-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 40px;
      height: 40px;
      background-color: #fff;
      border: 2px solid #007bff;
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      z-index: 1001;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      transition: left 0.3s ease;
    }

    .toggle-btn.sidebar-hidden {
      left: 20px;
    }

    .toggle-btn.sidebar-visible {
      left: 380px;
    }
     
    .card-header {
      font-weight: bold;
      padding: 6px;
      background-color: #f8f9fa;
      border-radius: 3px;
      margin-bottom: 8px;
    }
     
    .control-panel {
      background-color: #ffffff;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }

    .input-group {
      margin-bottom: 10px;
    }

    .input-group label {
      display: block;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .input-group input, .input-group select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
    }

    .route-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }

    .route-controls input[type="color"] {
      width: 40px;
      height: 30px;
      padding: 0;
      border: none;
    }

    .route-controls input[type="number"] {
      width: 60px;
    }

    .status-message {
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      font-size: 14px;
    }

    .status-loading {
      background-color: #fff3cd;
      border: 1px solid #ffeaa7;
      color: #856404;
    }

    .status-success {
      background-color: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
    }

    .status-error {
      background-color: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
    }

    button {
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      border: none;
      border-radius: 4px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background-color: #0056b3;
    }

    button:disabled {
      background-color: #6c757d;
      cursor: not-allowed;
    }

    .small-btn {
      width: auto;
      padding: 5px 10px;
      margin: 2px;
      font-size: 12px;
    }

    .waypoint-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #f9f9f9;
    }

    .waypoint-item {
      display: flex;
      align-items: center;
      padding: 8px;
      border-bottom: 1px solid #eee;
      background-color: white;
      margin: 2px;
      border-radius: 3px;
    }

    .waypoint-item:last-child {
      border-bottom: none;
    }

    .waypoint-number {
      width: 25px;
      height: 25px;
      border-radius: 50%;
      background-color: #007bff;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      margin-right: 10px;
      flex-shrink: 0;
    }

    .waypoint-text {
      flex: 1;
      font-size: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .waypoint-controls {
      display: flex;
      gap: 5px;
      flex-shrink: 0;
    }

    .waypoint-controls button {
      width: 25px;
      height: 25px;
      padding: 0;
      font-size: 12px;
      margin: 0;
    }

    /* Route Management Styles */
    .route-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-bottom: 15px;
      border-bottom: 2px solid #dee2e6;
      padding-bottom: 10px;
    }

    .route-tab {
      padding: 8px 12px;
      border: 1px solid #dee2e6;
      border-radius: 4px 4px 0 0;
      background-color: #f8f9fa;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 5px;
      min-width: 80px;
      justify-content: center;
    }

    .route-tab.active {
      background-color: #007bff;
      color: white;
      border-color: #007bff;
    }

    .route-tab .color-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.2);
    }

    .route-tab .close-btn {
      margin-left: 5px;
      background: none;
      border: none;
      color: inherit;
      cursor: pointer;
      padding: 0;
      width: auto;
      height: auto;
      font-size: 14px;
      font-weight: bold;
    }

    .route-tab .close-btn:hover {
      background-color: rgba(255,255,255,0.2);
      border-radius: 50%;
    }

    .route-list {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #f9f9f9;
      margin-top: 10px;
    }

    .route-list-item {
      display: flex;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid #eee;
      background-color: white;
      margin: 2px;
      border-radius: 3px;
    }

    .route-list-item:last-child {
      border-bottom: none;
    }

    .route-info {
      flex: 1;
      font-size: 12px;
    }

    .route-name {
      font-weight: bold;
      margin-bottom: 2px;
    }

    .route-status {
      color: #666;
      font-size: 11px;
    }

    .visibility-btn {
      width: 30px;
      height: 30px;
      padding: 0;
      font-size: 14px;
      margin: 0;
    }

    .visibility-btn.hidden {
      background-color: #6c757d;
    }

    .zoom-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .zoom-controls button {
      width: 50px;
      height: 40px;
      font-size: 18px;
      font-weight: bold;
    }

    /* Crosshair center indicator */
    .map-crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 30px;
      height: 30px;
      pointer-events: none;
      z-index: 1000;
    }

    .map-crosshair::before,
    .map-crosshair::after {
      content: '';
      position: absolute;
      background-color: #ff0000;
      box-shadow: 0 0 0 1px #ffffff;
    }

    .map-crosshair::before {
      top: 50%;
      left: 2px;
      right: 2px;
      height: 2px;
      transform: translateY(-50%);
    }

    .map-crosshair::after {
      left: 50%;
      top: 2px;
      bottom: 2px;
      width: 2px;
      transform: translateX(-50%);
    }

    .map-crosshair .center-circle {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 8px;
      border: 2px solid #ff0000;
      border-radius: 50%;
      background-color: #ffffff;
      box-shadow: 0 0 0 1px #ffffff;
    }
  </style>
</head>
 
<body>
  <div id="map"></div>
  
  <!-- Map crosshair indicator -->
  <div id="map-crosshair" class="map-crosshair" style="display: none;">
    <div class="center-circle"></div>
  </div>
  
  <div class="toggle-btn sidebar-visible" id="toggle-btn" onclick="RouteFinderApp.ui.toggleSidebar()">
    ‚ò∞
  </div>
  
  <div class="sidebar" id="sidebar">
    <div id="status-message" class="status-message status-loading">
      <strong>üîÑ Initializing...</strong><br>
      Loading mapping application...
    </div>

    <!-- Route Management Section -->
    <div class="control-panel" id="route-management" style="display: none;">
      <div class="card-header">üó∫Ô∏è Route Management</div>
      
      <div class="route-tabs" id="route-tabs">
        <!-- Route tabs will be dynamically generated -->
      </div>
      
      <button onclick="RouteFinderApp.routes.createNewRoute()">‚ûï New Route</button>
      
      <div style="display: flex; gap: 5px; margin: 5px 0;">
        <button onclick="RouteFinderApp.fileManager.exportRoutes()" style="flex: 1; font-size: 12px; height: 35px;">üì§ Export Routes</button>
        <button onclick="RouteFinderApp.fileManager.triggerImportRoutes()" style="flex: 1; font-size: 12px; height: 35px;">üì• Import Routes</button>
      </div>
      
      <!-- Hidden file input for importing -->
      <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="RouteFinderApp.fileManager.importRoutes(event)">
      
      <div class="route-list" id="route-list" style="display: none;">
        <!-- Route list items will be dynamically generated -->
      </div>
      
      <button onclick="RouteFinderApp.ui.toggleRouteList()" id="route-list-toggle" style="display: none;">üìã Show All Routes</button>
    </div>

    <!-- Current Route Controls -->
    <div class="control-panel" id="current-route-panel" style="display: none;">
      <div class="card-header" id="current-route-header">üéØ Current Route</div>
      
      <div class="input-group">
        <label>üü¢ Starting Point:</label>
        <input type="text" id="origin-input" placeholder="Enter address or place name">
        <button onclick="RouteFinderApp.geocoding.geocodeOrigin()" style="margin-top: 5px; font-size: 12px; height: 30px;">üìç Find Location</button>
      </div>
      
      <div class="input-group">
        <label>üî¥ Destination:</label>
        <input type="text" id="destination-input" placeholder="Enter address or place name">
        <button onclick="RouteFinderApp.geocoding.geocodeDestination()" style="margin-top: 5px; font-size: 12px; height: 30px;">üìç Find Location</button>
      </div>
      
      <div class="input-group">
        <label>üîµ Waypoints:</label>
        <input type="text" id="waypoint-input" placeholder="Enter intermediate stop">
        <div style="display: flex; gap: 5px; margin-top: 5px;">
          <button onclick="RouteFinderApp.waypoints.addWaypoint()" style="flex: 1; font-size: 12px; height: 30px;">‚ûï Add Waypoint</button>
          <button onclick="RouteFinderApp.waypoints.toggleWaypointMode()" id="waypoint-mode-btn" style="flex: 1; font-size: 12px; height: 30px;">üìç Click Map</button>
        </div>
        
        <div id="waypoint-list" class="waypoint-list" style="margin-top: 10px; display: none;">
          <!-- Waypoints will be added here dynamically -->
        </div>
      </div>
      
      <div class="input-group">
        <label>üöó Travel Mode:</label>
        <select id="profile-select">
          <option value="driving">üöó Driving</option>
          <option value="walking">üö∂ Walking</option>
          <option value="cycling">üö¥ Cycling</option>
        </select>
      </div>
      
      <button onclick="RouteFinderApp.routing.findRoute()">üó∫Ô∏è Find Route</button>
      <button onclick="RouteFinderApp.routes.clearCurrentRoute()">üóëÔ∏è Clear Route</button>
      
      <div class="route-controls">
        <label>Color:</label>
        <input type="color" id="routeColor" value="#ff0000" onchange="RouteFinderApp.routes.updateCurrentRouteStyle()">
        <label>Width:</label>
        <input type="number" id="routeWidth" value="8" min="1" max="20" onchange="RouteFinderApp.routes.updateCurrentRouteStyle()">
      </div>
    </div>

    <!-- Map Controls -->
    <div class="control-panel" id="map-controls" style="display: none;">
      <div class="card-header">üó∫Ô∏è Map Controls</div>
      
      <div class="input-group">
        <label>üé® Map Style:</label>
        <select id="map-style-select" onchange="RouteFinderApp.mapControls.changeMapStyle()">
          <option value="mapbox://styles/mapbox/streets-v11">Streets</option>
          <option value="mapbox://styles/mapbox/outdoors-v11">Outdoors</option>
          <option value="mapbox://styles/mapbox/light-v10">Light</option>
          <option value="mapbox://styles/mapbox/dark-v10">Dark</option>
          <option value="mapbox://styles/mapbox/satellite-v9">Satellite</option>
          <option value="mapbox://styles/mapbox/satellite-streets-v11">Satellite Streets</option>
          <option value="mapbox://styles/mapbox/navigation-day-v1">Navigation Day</option>
          <option value="mapbox://styles/mapbox/navigation-night-v1">Navigation Night</option>
        </select>
      </div>
      
      <div class="input-group">
        <label>üìç Center Map On:</label>
        <input type="text" id="center-input" placeholder="Enter address or coordinates">
        <div style="display: flex; gap: 5px; margin-top: 5px;">
          <button onclick="RouteFinderApp.mapControls.centerMapOnLocation()" style="flex: 1; font-size: 12px; height: 30px;">üéØ Center Map</button>
          <button onclick="RouteFinderApp.mapControls.toggleCenterMode()" id="center-mode-btn" style="flex: 1; font-size: 12px; height: 30px;">üìç Click Map</button>
        </div>
      </div>
      
      <div style="display: flex; gap: 10px; margin-bottom: 10px;">
        <button onclick="RouteFinderApp.mapControls.toggleCrosshair()" id="crosshair-toggle" style="flex: 1; font-size: 12px;">üéØ Show Center</button>
        <button onclick="RouteFinderApp.mapControls.getCurrentCenter()" style="flex: 1; font-size: 12px;">üìã Get Center</button>
      </div>
      
      <div class="zoom-controls">
        <button onclick="RouteFinderApp.mapControls.zoomIn()">+</button>
        <button onclick="RouteFinderApp.mapControls.zoomOut()">-</button>
        <button onclick="RouteFinderApp.mapControls.fitToData()" style="width: auto; flex: 1; font-size: 14px;">üìç Fit to Routes</button>
      </div>
    </div>

    <!-- Initialization Controls -->
    <div class="control-panel" id="init-controls">
      <div class="card-header">üöÄ Initialize Application</div>
      <button onclick="RouteFinderApp.init()" id="init-app-btn">üó∫Ô∏è Start Route Finder</button>
      <p style="font-size: 12px; color: #666; margin: 10px 0;">This will load the mapping libraries and start the full application.</p>
    </div>
  </div>

  <script>
    // Main Application Object with Modular Architecture
    const RouteFinderApp = (function() {
      'use strict';

      // Configuration Object - Centralized Settings
      const Config = {
        // Map Configuration
        mapbox: {
          accessToken: 'pk.eyJ1IjoiY2IyOSIsImEiOiJja3E4OHo3anowZGx1Mm9tcXF3ZmhyaWtwIn0.IQ5rY622AU9GOETrqa9NBw',
          style: 'mapbox://styles/mapbox/streets-v11',
          center: [-84.5, 38.05],
          zoom: 10
        },
        
        // Route Configuration
        routes: {
          colors: ['#ff0000', '#00ff00', '#0066ff', '#ff6600', '#ff00ff', '#00ffff', '#ffff00', '#990000', '#009900', '#000099'],
          defaultWidth: 8,
          defaultProfile: 'driving'
        },
        
        // UI Configuration
        ui: {
          sidebarTransitionDuration: 300,
          statusMessageDuration: 5000
        },
        
        // Timing Configuration
        timing: {
          mapLoadDelay: 1000,
          libraryLoadTimeout: 30000,
          geocodingDelay: 500
        }
      };

      // Event System - Centralized Event Management
      const EventSystem = {
        events: {},
        
        on(event, callback) {
          if (!this.events[event]) {
            this.events[event] = [];
          }
          this.events[event].push(callback);
        },
        
        off(event, callback) {
          if (!this.events[event]) return;
          this.events[event] = this.events[event].filter(cb => cb !== callback);
        },
        
        emit(event, data) {
          if (!this.events[event]) return;
          this.events[event].forEach(callback => {
            try {
              callback(data);
            } catch (error) {
              console.error('Event callback error:', error);
            }
          });
        }
      };

      // Application State - Centralized State Management
      const State = {
        // Core state
        map: null,
        appInitialized: false,
        librariesLoaded: {
          mapbox: false,
          turf: false
        },
        
        // Route state
        routes: new Map(),
        currentRouteId: null,
        nextRouteId: 1,
        routeListVisible: false,
        
        // Interaction state
        interactions: {
          settingOrigin: true,
          addingWaypoint: false,
          settingMapCenter: false,
          crosshairVisible: false
        },
        
        // Getters
        getCurrentRoute() {
          return this.routes.get(this.currentRouteId);
        },
        
        getAllRoutes() {
          return Array.from(this.routes.values());
        }
      };

      // Utility Functions
      const Utils = {
        updateStatus(message, type) {
          const statusEl = document.getElementById('status-message');
          if (statusEl) {
            statusEl.className = 'status-message status-' + type;
            statusEl.innerHTML = message;
          }
          console.log('STATUS: ' + message);
          EventSystem.emit('statusUpdated', { message, type });
        },
        
        createEmptyRoute(id = null) {
          const routeId = id || State.nextRouteId++;
          return {
            id: routeId,
            name: `Route ${routeId}`,
            origin: null,
            destination: null,
            waypoints: [],
            profile: Config.routes.defaultProfile,
            color: Config.routes.colors[(routeId - 1) % Config.routes.colors.length],
            width: Config.routes.defaultWidth,
            routeData: null,
            visible: true,
            status: 'empty'
          };
        },
        
        formatCoordinates(coords, precision = 4) {
          return `${coords[1].toFixed(precision)}, ${coords[0].toFixed(precision)}`;
        }
      };

      // Map Management Module
      const MapManager = {
        init() {
          if (!State.librariesLoaded.mapbox || !State.librariesLoaded.turf) {
            throw new Error('Required libraries not loaded');
          }
          
          Utils.updateStatus('<strong>üó∫Ô∏è Initializing Map...</strong><br>Creating map instance...', 'loading');
          
          mapboxgl.accessToken = Config.mapbox.accessToken;
          
          State.map = new mapboxgl.Map({
            container: 'map',
            style: Config.mapbox.style,
            center: Config.mapbox.center,
            zoom: Config.mapbox.zoom
          });
          
          State.map.on('load', () => {
            console.log('Map loaded successfully');
            this.setupMapFeatures();
            this.setupEventHandlers();
            EventSystem.emit('mapLoaded');
          });
          
          State.map.on('error', (e) => {
            console.error('Map error:', e);
            Utils.updateStatus('<strong>‚ùå Map Error</strong><br>Failed to initialize map', 'error');
            EventSystem.emit('mapError', e);
          });
        },
        
        setupMapFeatures() {
          // Add obstacles
          const obstacle = turf.buffer(this.getClearanceData(), 0.25, { units: 'kilometers' });
          
          State.map.addSource('obstacles', {
            type: 'geojson',
            data: obstacle
          });

          State.map.addLayer({
            id: 'obstacles',
            type: 'fill',
            source: 'obstacles',
            paint: {
              'fill-color': '#ff0000',
              'fill-opacity': 0.3
            }
          });
          
          console.log('Map features setup complete');
        },
        
        setupEventHandlers() {
          State.map.on('click', (e) => EventSystem.emit('mapClicked', e));
        },
        
        getClearanceData() {
          return {
            type: 'FeatureCollection',
            features: [
              { type: 'Feature', geometry: { type: 'Point', coordinates: [-84.47426, 38.06673] }, properties: { clearance: "13' 2\"" } },
              { type: 'Feature', geometry: { type: 'Point', coordinates: [-84.47208, 38.06694] }, properties: { clearance: "13' 7\"" } },
              { type: 'Feature', geometry: { type: 'Point', coordinates: [-84.60485, 38.12184] }, properties: { clearance: "13' 7\"" } },
              { type: 'Feature', geometry: { type: 'Point', coordinates: [-84.61905, 37.87504] }, properties: { clearance: "12' 0\"" } },
              { type: 'Feature', geometry: { type: 'Point', coordinates: [-84.55946, 38.30213] }, properties: { clearance: "13' 6\"" } },
              { type: 'Feature', geometry: { type: 'Point', coordinates: [-84.27235, 38.04954] }, properties: { clearance: "13' 6\"" } },
              { type: 'Feature', geometry: { type: 'Point', coordinates: [-84.27264, 37.82917] }, properties: { clearance: "11' 6\"" } }
            ]
          };
        }
      };

      // Route Management Module
      const RouteManager = {
        createNewRoute() {
          const newRoute = Utils.createEmptyRoute();
          State.routes.set(newRoute.id, newRoute);
          
          this.addRouteToMap(newRoute.id);
          this.switchToRoute(newRoute.id);
          
          EventSystem.emit('routeCreated', newRoute);
          EventSystem.emit('routesUpdated');
          
          console.log(`Created new route ${newRoute.id}`);
        },
        
        addRouteToMap(routeId) {
          const route = State.routes.get(routeId);
          if (!route || !State.map) return;

          // Add route line source and layer
          State.map.addSource(`route-${routeId}`, {
            type: 'geojson',
            data: { type: 'FeatureCollection', features: [] }
          });

          State.map.addLayer({
            id: `route-${routeId}`,
            type: 'line',
            source: `route-${routeId}`,
            layout: { 'line-join': 'round', 'line-cap': 'round' },
            paint: { 
              'line-color': route.color, 
              'line-width': route.width,
              'line-opacity': route.visible ? 1 : 0
            }
          });

          // Add waypoints source and layer
          State.map.addSource(`waypoints-${routeId}`, {
            type: 'geojson',
            data: { type: 'FeatureCollection', features: [] }
          });

          State.map.addLayer({
            id: `waypoints-${routeId}`,
            type: 'circle',
            source: `waypoints-${routeId}`,
            paint: {
              'circle-radius': 6,
              'circle-color': ['get', 'color'],
              'circle-stroke-color': '#ffffff',
              'circle-stroke-width': 2,
              'circle-opacity': route.visible ? 1 : 0,
              'circle-stroke-opacity': route.visible ? 1 : 0
            }
          });
        },
        
        switchToRoute(routeId) {
          State.currentRouteId = routeId;
          const route = State.routes.get(routeId);
          if (!route) return;

          // Update UI
          document.getElementById('origin-input').value = route.origin ? Utils.formatCoordinates(route.origin) : '';
          document.getElementById('destination-input').value = route.destination ? Utils.formatCoordinates(route.destination) : '';
          document.getElementById('profile-select').value = route.profile;
          document.getElementById('routeColor').value = route.color;
          document.getElementById('routeWidth').value = route.width;
          document.getElementById('current-route-header').textContent = `üéØ ${route.name}`;

          EventSystem.emit('routeSwitched', route);
          EventSystem.emit('waypointsUpdated');
        },
        
        updateRouteOnMap(routeId) {
          const route = State.routes.get(routeId);
          if (!route || !State.map) return;
          
          // Update route line
          const routeFeatures = [];
          if (route.routeData) {
            routeFeatures.push({
              type: 'Feature',
              geometry: route.routeData.geometry
            });
          }
          
          State.map.getSource(`route-${routeId}`).setData({
            type: 'FeatureCollection',
            features: routeFeatures
          });
          
          // Update waypoints
          const waypointFeatures = [];
          let featureId = 0;
          
          if (route.origin) {
            waypointFeatures.push({
              type: 'Feature',
              id: featureId++,
              geometry: { type: 'Point', coordinates: route.origin },
              properties: { color: '#00ff00', type: 'origin' }
            });
          }
          
          route.waypoints.forEach((waypoint, index) => {
            waypointFeatures.push({
              type: 'Feature',
              id: featureId++,
              geometry: { type: 'Point', coordinates: waypoint },
              properties: { color: '#0066ff', type: 'waypoint', index: index }
            });
          });
          
          if (route.destination) {
            waypointFeatures.push({
              type: 'Feature',
              id: featureId++,
              geometry: { type: 'Point', coordinates: route.destination },
              properties: { color: '#ff0000', type: 'destination' }
            });
          }
          
          State.map.getSource(`waypoints-${routeId}`).setData({
            type: 'FeatureCollection',
            features: waypointFeatures
          });
        },
        
        deleteRoute(routeId) {
          if (State.routes.size <= 1) {
            Utils.updateStatus('<strong>‚ùå Cannot Delete</strong><br>Must have at least one route', 'error');
            return;
          }

          // Remove from map
          ['route', 'waypoints'].forEach(type => {
            const layerId = `${type}-${routeId}`;
            if (State.map.getLayer(layerId)) State.map.removeLayer(layerId);
            if (State.map.getSource(layerId)) State.map.removeSource(layerId);
          });

          State.routes.delete(routeId);

          // Switch to another route if we deleted the current one
          if (State.currentRouteId === routeId) {
            const remainingRoutes = Array.from(State.routes.keys());
            this.switchToRoute(remainingRoutes[0]);
          }

          EventSystem.emit('routeDeleted', routeId);
          EventSystem.emit('routesUpdated');
        },
        
        clearCurrentRoute() {
          const route = State.getCurrentRoute();
          if (!route) return;
          
          route.origin = null;
          route.destination = null;
          route.waypoints = [];
          route.routeData = null;
          route.status = 'empty';
          
          document.getElementById('origin-input').value = '';
          document.getElementById('destination-input').value = '';
          document.getElementById('waypoint-input').value = '';
          
          this.updateRouteOnMap(State.currentRouteId);
          EventSystem.emit('routeCleared', route);
          EventSystem.emit('waypointsUpdated');
          
          Utils.updateStatus('<strong>üóëÔ∏è Route Cleared</strong><br>All data removed from current route', 'success');
        },
        
        updateCurrentRouteStyle() {
          const route = State.getCurrentRoute();
          if (!route) return;
          
          route.color = document.getElementById('routeColor').value;
          route.width = parseInt(document.getElementById('routeWidth').value);
          
          if (State.map.getLayer(`route-${State.currentRouteId}`)) {
            State.map.setPaintProperty(`route-${State.currentRouteId}`, 'line-color', route.color);
            State.map.setPaintProperty(`route-${State.currentRouteId}`, 'line-width', route.width);
          }
          
          EventSystem.emit('routeStyleUpdated', route);
        },
        
        toggleRouteVisibility(routeId) {
          const route = State.routes.get(routeId);
          if (!route) return;

          route.visible = !route.visible;
          
          ['route', 'waypoints'].forEach(type => {
            const layerId = `${type}-${routeId}`;
            if (State.map.getLayer(layerId)) {
              const opacityProperty = type === 'route' ? 'line-opacity' : 'circle-opacity';
              const strokeOpacityProperty = type === 'waypoints' ? 'circle-stroke-opacity' : null;
              
              State.map.setPaintProperty(layerId, opacityProperty, route.visible ? 1 : 0);
              if (strokeOpacityProperty) {
                State.map.setPaintProperty(layerId, strokeOpacityProperty, route.visible ? 1 : 0);
              }
            }
          });
          
          EventSystem.emit('routeVisibilityToggled', route);
        }
      };

      // Geocoding Module
      const GeocodingManager = {
        geocodeOrigin() {
          const address = document.getElementById('origin-input').value;
          if (!address.trim()) return;
          
          this.geocodeAddress(address, (coords) => {
            const route = State.getCurrentRoute();
            if (route) {
              route.origin = coords;
              document.getElementById('origin-input').value = Utils.formatCoordinates(coords);
              RouteManager.updateRouteOnMap(State.currentRouteId);
              Utils.updateStatus('<strong>‚úÖ Origin Found</strong><br>Location geocoded successfully', 'success');
              EventSystem.emit('originSet', coords);
            }
          });
        },
        
        geocodeDestination() {
          const address = document.getElementById('destination-input').value;
          if (!address.trim()) return;
          
          this.geocodeAddress(address, (coords) => {
            const route = State.getCurrentRoute();
            if (route) {
              route.destination = coords;
              document.getElementById('destination-input').value = Utils.formatCoordinates(coords);
              RouteManager.updateRouteOnMap(State.currentRouteId);
              Utils.updateStatus('<strong>‚úÖ Destination Found</strong><br>Location geocoded successfully', 'success');
              EventSystem.emit('destinationSet', coords);
            }
          });
        },
        
        geocodeAddress(address, callback) {
          const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(address)}.json?access_token=${mapboxgl.accessToken}`;
          
          fetch(url)
            .then(response => response.json())
            .then(data => {
              if (data.features && data.features.length > 0) {
                callback(data.features[0].center);
              } else {
                Utils.updateStatus('<strong>‚ùå Location Not Found</strong><br>Could not geocode the address', 'error');
              }
            })
            .catch(error => {
              console.error('Geocoding error:', error);
              Utils.updateStatus('<strong>‚ùå Geocoding Error</strong><br>Failed to find location', 'error');
            });
        }
      };

      // Waypoint Management Module
      const WaypointManager = {
        addWaypoint() {
          const address = document.getElementById('waypoint-input').value;
          if (!address.trim()) return;
          
          GeocodingManager.geocodeAddress(address, (coords) => {
            this.addWaypointAtCoordinates(coords);
            document.getElementById('waypoint-input').value = '';
          });
        },
        
        addWaypointAtCoordinates(coords) {
          const route = State.getCurrentRoute();
          if (!route) return;
          
          route.waypoints.push(coords);
          RouteManager.updateRouteOnMap(State.currentRouteId);
          EventSystem.emit('waypointAdded', coords);
          Utils.updateStatus('<strong>‚úÖ Waypoint Added</strong><br>Intermediate stop added to route', 'success');
        },
        
        removeWaypoint(index) {
          const route = State.getCurrentRoute();
          if (!route) return;
          
          const removed = route.waypoints.splice(index, 1)[0];
          
          if (route.routeData) {
            route.routeData = null;
            RouteManager.updateRouteOnMap(State.currentRouteId);
          }
          
          EventSystem.emit('waypointRemoved', { index, waypoint: removed });
        },
        
        toggleWaypointMode() {
          State.interactions.addingWaypoint = !State.interactions.addingWaypoint;
          const btn = document.getElementById('waypoint-mode-btn');
          btn.textContent = State.interactions.addingWaypoint ? 'üõë Stop Adding' : 'üìç Click Map';
          btn.style.backgroundColor = State.interactions.addingWaypoint ? '#dc3545' : '#007bff';
          
          if (State.interactions.addingWaypoint) {
            Utils.updateStatus('<strong>üìç Waypoint Mode</strong><br>Click on map to add waypoints', 'loading');
          } else {
            Utils.updateStatus('<strong>üéâ Ready!</strong><br>Multi-route mapper is ready to use', 'success');
          }
          
          EventSystem.emit('waypointModeToggled', State.interactions.addingWaypoint);
        }
      };

      // Routing Module
      const RoutingManager = {
        findRoute() {
          const route = State.getCurrentRoute();
          if (!route || !route.origin || !route.destination) {
            Utils.updateStatus('<strong>‚ùå Missing Data</strong><br>Need both origin and destination', 'error');
            return;
          }
          
          Utils.updateStatus('<strong>üîç Finding Route...</strong><br>Calculating best path', 'loading');
          
          let coordinates = [route.origin];
          coordinates = coordinates.concat(route.waypoints);
          coordinates.push(route.destination);
          
          const coordsString = coordinates.map(coord => `${coord[0]},${coord[1]}`).join(';');
          const profile = route.profile;
          
          const url = `https://api.mapbox.com/directions/v5/mapbox/${profile}/${coordsString}?geometries=geojson&access_token=${mapboxgl.accessToken}`;
          
          fetch(url)
            .then(response => response.json())
            .then(data => {
              if (data.routes && data.routes.length > 0) {
                route.routeData = data.routes[0];
                route.status = 'calculated';
                RouteManager.updateRouteOnMap(State.currentRouteId);
                
                const duration = Math.round(route.routeData.duration / 60);
                const distance = (route.routeData.distance / 1000).toFixed(1);
                Utils.updateStatus(`<strong>‚úÖ Route Found!</strong><br>${duration} minutes, ${distance} km`, 'success');
                
                EventSystem.emit('routeCalculated', route);
              } else {
                Utils.updateStatus('<strong>‚ùå No Route Found</strong><br>Could not calculate route', 'error');
              }
            })
            .catch(error => {
              console.error('Routing error:', error);
              Utils.updateStatus('<strong>‚ùå Routing Error</strong><br>Failed to calculate route', 'error');
            });
        }
      };

      // Map Controls Module
      const MapControlsManager = {
        zoomIn() {
          if (State.map) State.map.zoomIn();
        },
        
        zoomOut() {
          if (State.map) State.map.zoomOut();
        },
        
        fitToData() {
          if (!State.map) return;
          
          const coordinates = [];
          State.routes.forEach(route => {
            if (route.visible && route.routeData) {
              coordinates.push(...route.routeData.geometry.coordinates);
            }
          });
          
          if (coordinates.length === 0) {
            Utils.updateStatus('<strong>‚ÑπÔ∏è No Data</strong><br>No visible routes to fit to', 'loading');
            return;
          }
          
          const bounds = coordinates.reduce((bounds, coord) => {
            return bounds.extend(coord);
          }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));
          
          State.map.fitBounds(bounds, { padding: 50 });
        },
        
        toggleCrosshair() {
          State.interactions.crosshairVisible = !State.interactions.crosshairVisible;
          const crosshair = document.getElementById('map-crosshair');
          const toggleBtn = document.getElementById('crosshair-toggle');
          
          crosshair.style.display = State.interactions.crosshairVisible ? 'block' : 'none';
          toggleBtn.textContent = State.interactions.crosshairVisible ? 'üéØ Hide Center' : 'üéØ Show Center';
          toggleBtn.style.backgroundColor = State.interactions.crosshairVisible ? '#dc3545' : '#007bff';
        },
        
        centerMapOnLocation() {
          const input = document.getElementById('center-input').value.trim();
          if (!input) {
            Utils.updateStatus('<strong>‚ùå No Input</strong><br>Please enter an address or coordinates', 'error');
            return;
          }
          
          const coordMatch = input.match(/^(-?\d+\.?\d*),\s*(-?\d+\.?\d*)$/);
          if (coordMatch) {
            const lat = parseFloat(coordMatch[1]);
            const lng = parseFloat(coordMatch[2]);
            
            if (lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
              State.map.flyTo({ center: [lng, lat], zoom: 14, duration: 2000 });
              Utils.updateStatus(`<strong>üìç Map Centered</strong><br>Coordinates: ${lat.toFixed(4)}, ${lng.toFixed(4)}`, 'success');
              return;
            }
          }
          
          Utils.updateStatus('<strong>üîç Finding Location...</strong><br>Searching for address', 'loading');
          GeocodingManager.geocodeAddress(input, (coords) => {
            State.map.flyTo({ center: coords, zoom: 14, duration: 2000 });
            Utils.updateStatus(`<strong>üìç Map Centered</strong><br>Location found and centered`, 'success');
          });
        },
        
        toggleCenterMode() {
          State.interactions.settingMapCenter = !State.interactions.settingMapCenter;
          const btn = document.getElementById('center-mode-btn');
          btn.textContent = State.interactions.settingMapCenter ? 'üõë Stop Mode' : 'üìç Click Map';
          btn.style.backgroundColor = State.interactions.settingMapCenter ? '#dc3545' : '#007bff';
          
          if (State.interactions.settingMapCenter) {
            Utils.updateStatus('<strong>üìç Center Mode</strong><br>Click on map to center at that location', 'loading');
          } else {
            Utils.updateStatus('<strong>üéâ Ready!</strong><br>Multi-route mapper is ready to use', 'success');
          }
        },
        
        getCurrentCenter() {
          if (!State.map) return;
          
          const center = State.map.getCenter();
          const centerText = `${center.lat.toFixed(6)}, ${center.lng.toFixed(6)}`;
          
          if (navigator.clipboard) {
            navigator.clipboard.writeText(centerText).then(() => {
              Utils.updateStatus(`<strong>üìã Center Copied</strong><br>${centerText}`, 'success');
            }).catch(() => {
              Utils.updateStatus(`<strong>üìç Map Center</strong><br>${centerText}`, 'success');
            });
          } else {
            Utils.updateStatus(`<strong>üìç Map Center</strong><br>${centerText}`, 'success');
          }
          
          document.getElementById('center-input').value = centerText;
        },
        
        changeMapStyle() {
          if (!State.map) return;
          
          const selectedStyle = document.getElementById('map-style-select').value;
          
          Utils.updateStatus('<strong>üé® Changing Map Style...</strong><br>Loading new style', 'loading');
          
          State.map.setStyle(selectedStyle);
          
          // Re-add custom layers after style loads
          State.map.once('style.load', () => {
            // Re-add obstacles layer
            MapManager.setupMapFeatures();
            
            // Re-add all route layers
            State.routes.forEach((route, routeId) => {
              RouteManager.addRouteToMap(routeId);
              RouteManager.updateRouteOnMap(routeId);
            });
            
            Utils.updateStatus('<strong>‚úÖ Map Style Changed</strong><br>Style updated successfully', 'success');
            EventSystem.emit('mapStyleChanged', selectedStyle);
          });
        }
      };

      // File Management Module
      const FileManager = {
        exportRoutes() {
          if (State.routes.size === 0) {
            Utils.updateStatus('<strong>‚ùå No Routes</strong><br>No routes to export', 'error');
            return;
          }

          try {
            const exportData = {
              version: "1.0",
              exportDate: new Date().toISOString(),
              totalRoutes: State.routes.size,
              routes: State.getAllRoutes().map(route => ({
                id: route.id,
                name: route.name,
                origin: route.origin,
                destination: route.destination,
                waypoints: route.waypoints,
                profile: route.profile,
                color: route.color,
                width: route.width,
                visible: route.visible,
                status: route.status,
                routeStats: route.routeData ? {
                  duration: route.routeData.duration,
                  distance: route.routeData.distance
                } : null
              }))
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `routes_export_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            
            Utils.updateStatus(`<strong>üì§ Routes Exported</strong><br>Downloaded ${State.routes.size} routes successfully`, 'success');
            
          } catch (error) {
            console.error('Export error:', error);
            Utils.updateStatus('<strong>‚ùå Export Failed</strong><br>Could not export routes', 'error');
          }
        },
        
        triggerImportRoutes() {
          document.getElementById('import-file-input').click();
        },
        
        importRoutes(event) {
          const file = event.target.files[0];
          if (!file) return;

          if (!file.name.endsWith('.json')) {
            Utils.updateStatus('<strong>‚ùå Invalid File</strong><br>Please select a JSON file', 'error');
            return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const importData = JSON.parse(e.target.result);
              
              if (!importData.routes || !Array.isArray(importData.routes)) {
                throw new Error('Invalid route data structure');
              }

              Utils.updateStatus('<strong>üì• Importing Routes...</strong><br>Processing route data', 'loading');

              if (State.routes.size > 0) {
                const confirmClear = confirm(`This will replace your current ${State.routes.size} route(s). Continue?`);
                if (!confirmClear) {
                  Utils.updateStatus('<strong>‚ùå Import Cancelled</strong><br>Existing routes preserved', 'error');
                  return;
                }
              }

              // Clear existing routes
              State.routes.forEach((route, id) => {
                ['route', 'waypoints'].forEach(type => {
                  const layerId = `${type}-${id}`;
                  if (State.map.getLayer(layerId)) State.map.removeLayer(layerId);
                  if (State.map.getSource(layerId)) State.map.removeSource(layerId);
                });
              });

              State.routes.clear();

              // Import new routes
              let importedCount = 0;
              let maxId = 0;

              importData.routes.forEach(routeData => {
                const newRoute = {
                  id: routeData.id,
                  name: routeData.name || `Route ${routeData.id}`,
                  origin: routeData.origin || null,
                  destination: routeData.destination || null,
                  waypoints: routeData.waypoints || [],
                  profile: routeData.profile || 'driving',
                  color: routeData.color || Config.routes.colors[routeData.id % Config.routes.colors.length],
                  width: routeData.width || 8,
                  visible: routeData.visible !== undefined ? routeData.visible : true,
                  status: routeData.status || 'empty',
                  routeData: null
                };

                State.routes.set(newRoute.id, newRoute);
                RouteManager.addRouteToMap(newRoute.id);
                maxId = Math.max(maxId, newRoute.id);
                importedCount++;
              });

              State.nextRouteId = maxId + 1;

              if (State.routes.size > 0) {
                const firstRouteId = Array.from(State.routes.keys())[0];
                RouteManager.switchToRoute(firstRouteId);
              }

              EventSystem.emit('routesImported', importedCount);
              
              const importInfo = importData.exportDate ? 
                `<br>From: ${new Date(importData.exportDate).toLocaleDateString()}` : '';
              
              Utils.updateStatus(`<strong>üì• Import Complete</strong><br>Imported ${importedCount} routes${importInfo}`, 'success');

            } catch (error) {
              console.error('Import error:', error);
              Utils.updateStatus('<strong>‚ùå Import Failed</strong><br>Invalid or corrupted file', 'error');
            }
          };

          reader.onerror = () => {
            Utils.updateStatus('<strong>‚ùå File Read Error</strong><br>Could not read the file', 'error');
          };

          reader.readAsText(file);
          event.target.value = '';
        }
      };

      // UI Management Module
      const UIManager = {
        init() {
          this.setupEventListeners();
        },
        
        setupEventListeners() {
          // Route events
          EventSystem.on('routeCreated', () => this.updateRouteTabs());
          EventSystem.on('routeDeleted', () => this.updateRouteTabs());
          EventSystem.on('routesUpdated', () => this.updateRouteList());
          EventSystem.on('routeSwitched', () => this.updateRouteTabs());
          EventSystem.on('waypointsUpdated', () => this.updateWaypointsList());
          EventSystem.on('waypointAdded', () => this.updateWaypointsList());
          EventSystem.on('waypointRemoved', () => this.updateWaypointsList());
          EventSystem.on('mapLoaded', () => this.showApplicationUI());
          EventSystem.on('routesImported', () => {
            this.updateRouteTabs();
            this.updateRouteList();
          });
        },
        
        showApplicationUI() {
          document.getElementById('init-controls').style.display = 'none';
          document.getElementById('route-management').style.display = 'block';
          document.getElementById('current-route-panel').style.display = 'block';
          document.getElementById('map-controls').style.display = 'block';
        },
        
        updateRouteTabs() {
          const tabsContainer = document.getElementById('route-tabs');
          tabsContainer.innerHTML = '';

          State.routes.forEach((route, id) => {
            const tab = document.createElement('div');
            tab.className = `route-tab ${id === State.currentRouteId ? 'active' : ''}`;
            tab.innerHTML = `
              <div class="color-indicator" style="background-color: ${route.color}"></div>
              <span>${route.name}</span>
              <button class="close-btn" onclick="event.stopPropagation(); RouteFinderApp.routes.deleteRoute(${id})" title="Delete route">√ó</button>
            `;
            tab.onclick = () => RouteManager.switchToRoute(id);
            tabsContainer.appendChild(tab);
          });

          const toggleBtn = document.getElementById('route-list-toggle');
          if (State.routes.size > 1) {
            toggleBtn.style.display = 'block';
          } else {
            toggleBtn.style.display = 'none';
            document.getElementById('route-list').style.display = 'none';
            State.routeListVisible = false;
          }
        },
        
        updateRouteList() {
          const listContainer = document.getElementById('route-list');
          listContainer.innerHTML = '';

          State.routes.forEach((route, id) => {
            const item = document.createElement('div');
            item.className = 'route-list-item';
            
            const statusText = this.getRouteStatusText(route);
            
            item.innerHTML = `
              <div class="color-indicator" style="background-color: ${route.color}; width: 16px; height: 16px; margin-right: 10px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.2);"></div>
              <div class="route-info">
                <div class="route-name">${route.name}</div>
                <div class="route-status">${statusText}</div>
              </div>
              <div class="route-controls">
                <button class="visibility-btn ${route.visible ? '' : 'hidden'}" onclick="RouteFinderApp.routes.toggleRouteVisibility(${id})" title="Toggle visibility">
                  ${route.visible ? 'üëÅÔ∏è' : 'üö´'}
                </button>
                <button class="small-btn" onclick="RouteFinderApp.routes.switchToRoute(${id})" title="Edit route">‚úèÔ∏è</button>
                <button class="small-btn" onclick="RouteFinderApp.routes.deleteRoute(${id})" title="Delete route">üóëÔ∏è</button>
              </div>
            `;
            listContainer.appendChild(item);
          });
        },
        
        updateWaypointsList() {
          const route = State.getCurrentRoute();
          if (!route) return;
          
          const waypointsList = document.getElementById('waypoint-list');
          
          if (route.waypoints.length === 0) {
            waypointsList.style.display = 'none';
            return;
          }
          
          waypointsList.style.display = 'block';
          waypointsList.innerHTML = '';
          
          route.waypoints.forEach((waypoint, index) => {
            const item = document.createElement('div');
            item.className = 'waypoint-item';
            item.innerHTML = `
              <div class="waypoint-number">${index + 1}</div>
              <div class="waypoint-text">${Utils.formatCoordinates(waypoint)}</div>
              <div class="waypoint-controls">
                <button onclick="RouteFinderApp.waypoints.removeWaypoint(${index})" title="Remove waypoint">√ó</button>
              </div>
            `;
            waypointsList.appendChild(item);
          });
        },
        
        getRouteStatusText(route) {
          if (!route.origin && !route.destination) return 'Empty route';
          if (!route.origin) return 'Missing origin';
          if (!route.destination) return 'Missing destination';
          if (route.routeData) {
            const duration = Math.round(route.routeData.duration / 60);
            const distance = (route.routeData.distance / 1000).toFixed(1);
            return `${duration} min, ${distance} km`;
          }
          return 'Ready to calculate';
        },
        
        toggleSidebar() {
          const sidebar = document.getElementById('sidebar');
          const toggleBtn = document.getElementById('toggle-btn');
          
          sidebar.classList.toggle('hidden');
          
          if (sidebar.classList.contains('hidden')) {
            toggleBtn.classList.remove('sidebar-visible');
            toggleBtn.classList.add('sidebar-hidden');
          } else {
            toggleBtn.classList.remove('sidebar-hidden');
            toggleBtn.classList.add('sidebar-visible');
          }
        },
        
        toggleRouteList() {
          const listContainer = document.getElementById('route-list');
          const toggleBtn = document.getElementById('route-list-toggle');
          
          State.routeListVisible = !State.routeListVisible;
          listContainer.style.display = State.routeListVisible ? 'block' : 'none';
          toggleBtn.textContent = State.routeListVisible ? 'üìã Hide Routes' : 'üìã Show All Routes';
        }
      };

      // Library Loader Module
      const LibraryLoader = {
        async loadLibraries() {
          Utils.updateStatus('<strong>üì• Loading Libraries...</strong><br>Downloading Mapbox GL and Turf.js...', 'loading');
          
          try {
            await this.loadMapboxGL();
            await this.loadTurf();
            return true;
          } catch (error) {
            Utils.updateStatus('<strong>‚ùå Failed to Load</strong><br>Could not load required libraries', 'error');
            return false;
          }
        },
        
        loadMapboxGL() {
          return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js';
            script.crossOrigin = 'anonymous';
            
            script.onload = () => {
              const css = document.createElement('link');
              css.rel = 'stylesheet';
              css.href = 'https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css';
              css.crossOrigin = 'anonymous';
              document.head.appendChild(css);
              
              State.librariesLoaded.mapbox = true;
              console.log('Mapbox GL loaded');
              resolve();
            };
            
            script.onerror = reject;
            document.head.appendChild(script);
          });
        },
        
        loadTurf() {
          return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/@turf/turf@6/turf.min.js';
            script.crossOrigin = 'anonymous';
            
            script.onload = () => {
              State.librariesLoaded.turf = true;
              console.log('Turf.js loaded');
              resolve();
            };
            
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }
      };

      // Map Click Handler
      const MapClickHandler = {
        init() {
          EventSystem.on('mapLoaded', () => {
            EventSystem.on('mapClicked', this.handleMapClick.bind(this));
          });
        },
        
        handleMapClick(e) {
          if (!State.appInitialized) return;
          
          const coords = [e.lngLat.lng, e.lngLat.lat];
          
          if (State.interactions.settingMapCenter) {
            this.handleCenterMapClick(coords);
            return;
          }
          
          if (State.interactions.addingWaypoint) {
            WaypointManager.addWaypointAtCoordinates(coords);
            return;
          }
          
          const route = State.getCurrentRoute();
          if (!route) return;
          
          if (State.interactions.settingOrigin) {
            route.origin = coords;
            document.getElementById('origin-input').value = Utils.formatCoordinates(coords);
            State.interactions.settingOrigin = false;
            RouteManager.updateRouteOnMap(State.currentRouteId);
            Utils.updateStatus('<strong>‚úÖ Origin Set</strong><br>Click on map to set destination', 'success');
          } else {
            route.destination = coords;
            document.getElementById('destination-input').value = Utils.formatCoordinates(coords);
            State.interactions.settingOrigin = true;
            RouteManager.updateRouteOnMap(State.currentRouteId);
            Utils.updateStatus('<strong>‚úÖ Destination Set</strong><br>Ready to find route', 'success');
          }
          
          EventSystem.emit('waypointsUpdated');
        },
        
        handleCenterMapClick(coords) {
          State.map.flyTo({ center: coords, duration: 1500 });
          document.getElementById('center-input').value = Utils.formatCoordinates(coords, 6);
          
          State.interactions.settingMapCenter = false;
          const btn = document.getElementById('center-mode-btn');
          btn.textContent = 'üìç Click Map';
          btn.style.backgroundColor = '#007bff';
          
          Utils.updateStatus('<strong>üìç Map Centered</strong><br>Map centered on clicked location', 'success');
        }
      };

      // Main Application Initialization
      const App = {
        async init() {
          console.log('=== Multi-Route Mapper Starting ===');
          
          try {
            // Load required libraries
            const librariesLoaded = await LibraryLoader.loadLibraries();
            if (!librariesLoaded) {
              throw new Error('Failed to load required libraries');
            }
            
            // Initialize UI event system
            UIManager.init();
            MapClickHandler.init();
            
            // Initialize map
            MapManager.init();
            
            // Set up completion handler
            EventSystem.on('mapLoaded', () => {
              setTimeout(() => {
                RouteManager.createNewRoute();
                Utils.updateStatus('<strong>üéâ Ready!</strong><br>Multi-route mapper is ready to use', 'success');
                State.appInitialized = true;
              }, Config.timing.mapLoadDelay);
            });
            
          } catch (error) {
            console.error('Initialization error:', error);
            Utils.updateStatus('<strong>‚ùå Initialization Failed</strong><br>' + error.message, 'error');
          }
        }
      };

      // Public API - Expose modules for HTML onclick handlers
      return {
        // Core initialization
        init: App.init,
        
        // Module access for HTML onclick handlers
        routes: {
          createNewRoute: RouteManager.createNewRoute.bind(RouteManager),
          deleteRoute: RouteManager.deleteRoute.bind(RouteManager),
          switchToRoute: RouteManager.switchToRoute.bind(RouteManager),
          clearCurrentRoute: RouteManager.clearCurrentRoute.bind(RouteManager),
          updateCurrentRouteStyle: RouteManager.updateCurrentRouteStyle.bind(RouteManager),
          toggleRouteVisibility: RouteManager.toggleRouteVisibility.bind(RouteManager)
        },
        
        geocoding: {
          geocodeOrigin: GeocodingManager.geocodeOrigin.bind(GeocodingManager),
          geocodeDestination: GeocodingManager.geocodeDestination.bind(GeocodingManager)
        },
        
        waypoints: {
          addWaypoint: WaypointManager.addWaypoint.bind(WaypointManager),
          removeWaypoint: WaypointManager.removeWaypoint.bind(WaypointManager),
          toggleWaypointMode: WaypointManager.toggleWaypointMode.bind(WaypointManager)
        },
        
        routing: {
          findRoute: RoutingManager.findRoute.bind(RoutingManager)
        },
        
        mapControls: {
          zoomIn: MapControlsManager.zoomIn.bind(MapControlsManager),
          zoomOut: MapControlsManager.zoomOut.bind(MapControlsManager),
          fitToData: MapControlsManager.fitToData.bind(MapControlsManager),
          toggleCrosshair: MapControlsManager.toggleCrosshair.bind(MapControlsManager),
          centerMapOnLocation: MapControlsManager.centerMapOnLocation.bind(MapControlsManager),
          toggleCenterMode: MapControlsManager.toggleCenterMode.bind(MapControlsManager),
          getCurrentCenter: MapControlsManager.getCurrentCenter.bind(MapControlsManager),
          changeMapStyle: MapControlsManager.changeMapStyle.bind(MapControlsManager)
        },
        
        fileManager: {
          exportRoutes: FileManager.exportRoutes.bind(FileManager),
          triggerImportRoutes: FileManager.triggerImportRoutes.bind(FileManager),
          importRoutes: FileManager.importRoutes.bind(FileManager)
        },
        
        ui: {
          toggleSidebar: UIManager.toggleSidebar.bind(UIManager),
          toggleRouteList: UIManager.toggleRouteList.bind(UIManager)
        },
        
        // Development/debugging access
        _internal: {
          Config,
          State,
          EventSystem,
          Utils
        }
      };
    })();

    // Initialize when page loads
    window.addEventListener('load', function() {
      console.log('Page loaded, ready for initialization');
    });
  </script>
</body>
</html>
          
