<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Route Finder</title>
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
  <style>
    :root {
      /* ===== COLORS ===== */
      --color-primary: #3b82f6;
      --color-primary-hover: #2563eb;
      --color-primary-alpha: rgba(59, 130, 246, 0.1);
      --color-surface-primary: #ffffff;
      --color-surface-secondary: #f8fafc;
      --color-surface-hover: #f1f5f9;
      --color-border-light: #e2e8f0;
      --color-border-hover: #cbd5e1;
      --color-text-primary: #1e293b;
      --color-text-secondary: #64748b;
      --color-success: #10b981;
      --color-warning: #f59e0b;
      --color-danger: #ef4444;
      
      /* ===== SPACING ===== */
      --space-1: 0.25rem;
      --space-2: 0.5rem;
      --space-3: 0.75rem;
      --space-4: 1rem;
      --space-5: 1.25rem;
      --space-6: 1.5rem;
      --space-8: 2rem;
      --space-12: 3rem;
      
      /* ===== TYPOGRAPHY ===== */
      --font-size-xs: 0.75rem;
      --font-size-sm: 0.875rem;
      --font-size-base: 1rem;
      --font-size-lg: 1.125rem;
      --font-weight-normal: 400;
      --font-weight-medium: 500;
      --font-weight-semibold: 600;
      --font-weight-bold: 700;
      
      /* ===== BORDERS ===== */
      --border-radius-sm: 0.375rem;
      --border-radius-md: 0.5rem;
      --border-radius-lg: 0.75rem;
      
      /* ===== TRANSITIONS ===== */
      --transition-base: all 0.2s ease;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      background: var(--color-surface-secondary);
      color: var(--color-text-primary);
    }
    
    /* ===== LAYOUT ===== */
    .app-container {
      display: flex;
      height: 100vh;
    }
    
    .sidebar {
      width: 380px;
      background: var(--color-surface-primary);
      border-right: 1px solid var(--color-border-light);
      overflow-y: auto;
      padding: var(--space-4);
      display: flex;
      flex-direction: column;
      gap: var(--space-4);
    }
    
    .map-container {
      flex: 1;
      position: relative;
    }
    
    #map {
      width: 100%;
      height: 100%;
    }
    
    /* ===== CARDS ===== */
    .card {
      background: var(--color-surface-primary);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-lg);
      overflow: hidden;
    }
    
    .card-header {
      padding: var(--space-4);
      border-bottom: 1px solid var(--color-border-light);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: var(--transition-base);
    }
    
    .card-header:hover {
      background: var(--color-surface-hover);
    }
    
    .card-header h3 {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }
    
    .card-content {
      padding: var(--space-4);
    }
    
    .collapsible {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    /* ===== BUTTONS ===== */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-2);
      padding: var(--space-3) var(--space-4);
      border: 1px solid transparent;
      border-radius: var(--border-radius-md);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      cursor: pointer;
      transition: var(--transition-base);
      text-decoration: none;
      line-height: 1;
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    .btn-primary {
      background: var(--color-primary);
      color: white;
      border-color: var(--color-primary);
    }
    
    .btn-primary:hover:not(:disabled) {
      background: var(--color-primary-hover);
      border-color: var(--color-primary-hover);
    }
    
    .btn-secondary {
      background: var(--color-surface-secondary);
      color: var(--color-text-primary);
      border-color: var(--color-border-light);
    }
    
    .btn-secondary:hover:not(:disabled) {
      background: var(--color-surface-hover);
      border-color: var(--color-border-hover);
    }
    
    .btn-success {
      background: var(--color-success);
      color: white;
      border-color: var(--color-success);
    }
    
    .btn-danger {
      background: var(--color-danger);
      color: white;
      border-color: var(--color-danger);
    }
    
    .btn-small {
      padding: var(--space-2) var(--space-3);
      font-size: var(--font-size-xs);
    }
    
    .btn-full {
      width: 100%;
    }
    
    .button-group {
      display: flex;
      gap: var(--space-2);
      flex-wrap: wrap;
    }
    
    .button-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-2);
    }
    
    /* ===== FORMS ===== */
    .form-group {
      margin-bottom: var(--space-4);
    }
    
    .form-label {
      display: block;
      margin-bottom: var(--space-2);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      color: var(--color-text-primary);
    }
    
    .form-input,
    .form-select {
      width: 100%;
      padding: var(--space-3);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-md);
      font-size: var(--font-size-sm);
      transition: var(--transition-base);
      background: var(--color-surface-primary);
    }
    
    .form-input:focus,
    .form-select:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }
    
    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-3);
    }
    
    /* ===== TABS ===== */
    .route-tabs {
      display: flex;
      gap: var(--space-2);
      margin-bottom: var(--space-4);
      flex-wrap: wrap;
    }
    
    .route-tab {
      padding: var(--space-2) var(--space-3);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-md);
      cursor: pointer;
      transition: var(--transition-base);
      display: flex;
      align-items: center;
      gap: var(--space-2);
      font-size: var(--font-size-sm);
      background: var(--color-surface-secondary);
    }
    
    .route-tab.active {
      background: var(--color-primary);
      color: white;
      border-color: var(--color-primary);
    }
    
    .route-tab:hover:not(.active) {
      background: var(--color-surface-hover);
    }
    
    .route-color-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    /* ===== STATUS ===== */
    .status-message {
      padding: var(--space-3) var(--space-4);
      border-radius: var(--border-radius-md);
      font-size: var(--font-size-sm);
      margin-bottom: var(--space-4);
      display: none;
    }
    
    .status-message.success {
      background: rgba(16, 185, 129, 0.1);
      color: var(--color-success);
      border: 1px solid rgba(16, 185, 129, 0.2);
    }
    
    .status-message.error {
      background: rgba(239, 68, 68, 0.1);
      color: var(--color-danger);
      border: 1px solid rgba(239, 68, 68, 0.2);
    }
    
    .status-message.warning {
      background: rgba(245, 158, 11, 0.1);
      color: var(--color-warning);
      border: 1px solid rgba(245, 158, 11, 0.2);
    }
    
    /* ===== WAYPOINTS ===== */
    .waypoint-item {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      padding: var(--space-3);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-md);
      margin-bottom: var(--space-2);
      background: var(--color-surface-secondary);
    }
    
    .waypoint-controls {
      display: flex;
      gap: var(--space-1);
    }
    
    .waypoint-address {
      flex: 1;
      font-size: var(--font-size-sm);
      color: var(--color-text-primary);
    }
    
    /* ===== ROUTE LIST ===== */
    .route-list {
      margin-top: var(--space-4);
    }
    
    .route-item {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      padding: var(--space-3);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-md);
      margin-bottom: var(--space-2);
      background: var(--color-surface-secondary);
    }
    
    .route-controls {
      display: flex;
      gap: var(--space-1);
    }
    
    .route-name {
      flex: 1;
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
    }
    
    /* ===== ICONS ===== */
    .icon {
      font-size: 1.2em;
      opacity: 0.8;
    }
    
    .chevron {
      transition: transform 0.2s ease;
      font-size: 0.8em;
      color: var(--color-text-secondary);
    }
    
    .chevron.expanded {
      transform: rotate(90deg);
    }
    
    /* ===== MAP EXPORT DIALOG STYLES ===== */
    .map-export-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(4px);
    }
    
    .map-export-dialog {
      background: var(--color-surface-primary);
      border-radius: var(--border-radius-lg);
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      max-width: 500px;
      width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
    }
    
    .map-export-header {
      padding: var(--space-6) var(--space-6) var(--space-4);
      border-bottom: 1px solid var(--color-border-light);
    }
    
    .map-export-header h2 {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
      margin: 0;
    }
    
    .map-export-content {
      padding: var(--space-6);
    }
    
    .map-export-footer {
      padding: var(--space-4) var(--space-6) var(--space-6);
      display: flex;
      gap: var(--space-3);
      justify-content: flex-end;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="sidebar">
      <!-- Initialization Controls -->
<div id="init-controls" class="card" style="display: none;">
  <div class="card-header">
    <h3>🗺️ Route Finder</h3>
  </div>
  <div class="card-content">
    <div id="init-status" class="status-message"></div>
    
    <div class="form-group">
      <label class="form-label">Mapbox Access Token</label>
      <input type="password" class="form-input" id="mapbox-token" placeholder="Enter your Mapbox token...">
    </div>
    
    <button class="btn btn-primary btn-full" onclick="RouteFinderApp.init.initializeApp()">
      🚀 Initialize Map
    </button>
  </div>
</div>
          
          <button class="btn btn-primary btn-full" onclick="RouteFinderApp.init.initializeApp()">
            🚀 Initialize Map
          </button>
        </div>
      </div>

      <!-- Route Management -->
      <div class="card" id="route-management" style="display: none;">
        <div class="card-header" onclick="RouteFinderApp.ui.toggleSection('route-management-content')">
          <h3>
            <span>🛣️</span> Route Management
          </h3>
          <span class="chevron">▷</span>
        </div>
        <div class="card-content collapsible" id="route-management-content">
          <div class="route-tabs" id="route-tabs">
            <!-- Route tabs will be dynamically generated -->
          </div>
          
          <button class="btn btn-primary btn-full" onclick="RouteFinderApp.routes.createNewRoute()">
            <span>+</span> New Route
          </button>
          
          <!-- STEP 1 FIX: Moved route styling controls back to Route Management -->
          <div id="route-styling-controls" style="margin-top: var(--space-4); display: none;">
            <h4 style="margin-bottom: var(--space-3); font-size: var(--font-size-base); font-weight: var(--font-weight-semibold);">
              🎨 Route Styling
            </h4>
            
            <!-- Route Name -->
            <div class="form-group">
              <label class="form-label">Route Name</label>
              <input type="text" class="form-input" id="route-name-input" placeholder="Enter route name..." onchange="RouteFinderApp.routes.updateRouteName()">
            </div>

            <!-- Route Color and Width Grid -->
            <div class="form-grid">
              <div class="form-group">
                <label class="form-label">Color</label>
                <input type="color" class="form-input" id="route-color-input" onchange="RouteFinderApp.routes.updateRouteStyle()" value="#3b82f6">
              </div>
              <div class="form-group">
                <label class="form-label">Width</label>
                <select class="form-select" id="route-width-input" onchange="RouteFinderApp.routes.updateRouteStyle()">
                  <option value="2">Thin (2px)</option>
                  <option value="4" selected>Medium (4px)</option>
                  <option value="6">Thick (6px)</option>
                  <option value="8">Extra Thick (8px)</option>
                </select>
              </div>
            </div>
          </div>
          
          <div class="button-grid" style="margin-top: var(--space-4);">
            <button class="btn btn-secondary" onclick="RouteFinderApp.fileManager.exportRoutes()">
              <span>↑</span> Export Routes
            </button>
            <button class="btn btn-secondary" onclick="RouteFinderApp.fileManager.triggerImportRoutes()">
              <span>↓</span> Import Routes
            </button>
          </div>

          <div class="route-list" id="route-list" style="display: none;">
            <!-- Route list items will be dynamically generated -->
          </div>

          <button class="btn btn-secondary btn-full" onclick="RouteFinderApp.ui.toggleRouteList()" id="route-list-toggle" style="display: none; margin-top: var(--space-3);">
            ⋯ Show All Routes
          </button>
        </div>
      </div>

      <!-- Current Route Controls -->
      <div class="card" id="current-route-panel" style="display: none;">
        <div class="card-header" onclick="RouteFinderApp.ui.toggleSection('current-route-content')">
          <h3>
            <span>📍</span> Current Route
            <span id="current-route-indicator" style="margin-left: var(--space-2);"></span>
          </h3>
          <span class="chevron expanded">▷</span>
        </div>
        <div class="card-content collapsible" id="current-route-content">
          <!-- Travel Mode -->
          <div class="form-group">
            <label class="form-label">Travel Mode</label>
            <select class="form-select" id="travel-mode-select" onchange="RouteFinderApp.routes.updateTravelMode()">
              <option value="driving">🚗 Driving</option>
              <option value="walking">🚶 Walking</option>
              <option value="cycling">🚴 Cycling</option>
            </select>
          </div>

          <!-- Waypoint Management -->
          <div class="form-group">
            <label class="form-label">Add Waypoint</label>
            <div class="button-group">
              <input type="text" class="form-input" id="address-input" placeholder="Enter address or place name..." style="flex: 2;">
              <button class="btn btn-primary" onclick="RouteFinderApp.routes.addWaypoint()" style="flex: 2;">
                → Find Route
              </button>
              <button class="btn btn-secondary" onclick="RouteFinderApp.routes.clearCurrentRoute()" style="flex: 1;">
                ✕ Clear
              </button>
            </div>
          </div>

          <!-- Waypoints List -->
          <div id="waypoints-list" style="display: none;">
            <!-- Waypoints will be dynamically populated -->
          </div>

          <!-- Route Status -->
          <div id="route-status" class="status-message"></div>
        </div>
      </div>

      <!-- Map Controls -->
      <div class="card" id="map-controls" style="display: none;">
        <div class="card-header" onclick="RouteFinderApp.ui.toggleSection('map-controls-content')">
          <h3>
            <span>🗺️</span> Map Controls
          </h3>
          <span class="chevron expanded">▷</span>
        </div>
        <div class="card-content collapsible" id="map-controls-content">
          <div class="form-group">
            <label class="form-label">Center Location</label>
            <input type="text" class="form-input" id="center-location" placeholder="Enter location to center map..." value="New York, NY">
            <button class="btn btn-secondary btn-full" onclick="RouteFinderApp.mapControls.centerMap()" style="margin-top: var(--space-2);">
              📍 Center Map
            </button>
          </div>

          <div class="form-group">
            <label class="form-label">Map Style</label>
            <select class="form-select" id="map-style" onchange="RouteFinderApp.mapControls.changeStyle()">
              <option value="mapbox://styles/mapbox/streets-v12">Streets</option>
              <option value="mapbox://styles/mapbox/satellite-streets-v12">Satellite</option>
              <option value="mapbox://styles/mapbox/outdoors-v12">Outdoors</option>
              <option value="mapbox://styles/mapbox/light-v11">Light</option>
              <option value="mapbox://styles/mapbox/dark-v11">Dark</option>
            </select>
          </div>

          <div class="form-group">
            <label class="form-label">Zoom Level</label>
            <input type="range" class="form-input" id="zoom-level" min="1" max="20" value="10" onchange="RouteFinderApp.mapControls.setZoom()">
            <span id="zoom-value" style="font-size: var(--font-size-sm); color: var(--color-text-secondary);">10</span>
          </div>
        </div>
      </div>

      <!-- Obstacle Detection -->
      <div class="card" id="obstacle-controls" style="display: none;">
        <div class="card-header" onclick="RouteFinderApp.ui.toggleSection('obstacle-controls-content')">
          <h3>
            <span>⚠️</span> Obstacle Detection
          </h3>
          <span class="chevron expanded">▷</span>
        </div>
        <div class="card-content collapsible" id="obstacle-controls-content">
          <div class="form-group">
            <label class="form-label">Detection Settings</label>
            <div class="button-group">
              <button class="btn btn-secondary" onclick="RouteFinderApp.obstacles.toggleDetection()">
                🔍 Toggle Detection
              </button>
              <button class="btn btn-secondary" onclick="RouteFinderApp.obstacles.clearObstacles()">
                🗑️ Clear Obstacles
              </button>
            </div>
          </div>
          
          <div id="obstacle-status" class="status-message"></div>
          <div id="obstacles-list"></div>
        </div>
      </div>

      <!-- Export Map Button (will be moved to separate section in later steps) -->
      <button class="btn btn-primary btn-full" onclick="RouteFinderApp.mapExport.showExportDialog()" title="Export map as high-resolution image" style="margin-top: var(--space-4);">
        <span>📸</span> Export Map
      </button>
    </div>

    <div class="map-container">
      <div id="map"></div>
    </div>
  </div>

  <!-- File input for importing routes (hidden) -->
  <input type="file" id="route-file-input" accept=".json" style="display: none;">

  <script>
    // Global state management
    window.State = {
      map: null,
      mapboxToken: null,
      routes: new Map(),
      currentRouteId: null,
      isInitialized: false,
      obstacleDetection: false,
      
      getCurrentRoute() {
        return this.currentRouteId ? this.routes.get(this.currentRouteId) : null;
      },
      
      getAllRoutes() {
        return Array.from(this.routes.values());
      }
    };

    // Event system for component communication
    window.EventSystem = {
      listeners: new Map(),
      
      on(event, callback) {
        if (!this.listeners.has(event)) {
          this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
      },
      
      emit(event, data) {
        if (this.listeners.has(event)) {
          this.listeners.get(event).forEach(callback => callback(data));
        }
      }
    };

    // Utility functions
    window.Utils = {
      generateId() {
        return Date.now() + Math.random().toString(36).substr(2, 9);
      },

      createEmptyRoute() {
        return {
          id: this.generateId(),
          name: `Route ${window.State.routes.size + 1}`,
          origin: null,
          destination: null,
          waypoints: [],
          travelMode: 'driving',
          color: '#3b82f6',
          width: 4,
          visible: true,
          status: 'empty',
          routeData: null
        };
      },

      updateStatus(message, type = 'info', elementId = 'route-status') {
        const statusEl = document.getElementById(elementId);
        if (statusEl) {
          statusEl.innerHTML = message;
          statusEl.className = `status-message ${type}`;
          statusEl.style.display = 'block';
          
          if (type === 'success' || type === 'info') {
            setTimeout(() => {
              statusEl.style.display = 'none';
            }, 3000);
          }
        }
      }
    };

    // Main application object
    window.RouteFinderApp = {
      // Initialization module
      init: {
        initializeApp() {
          const token = 'pk.eyJ1IjoiY2IyOSIsImEiOiJja3E4OHo3anowZGx1Mm9tcXF3ZmhyaWtwIn0.IQ5rY622AU9GOETrqa9NBw';

// Skip the empty token check since we're using a hardcoded token

          window.State.mapboxToken = token;
          mapboxgl.accessToken = token;

          Utils.updateStatus('🔄 Initializing map...', 'info', 'init-status');

          try {
            this.createMap();
          } catch (error) {
            console.error('Map initialization error:', error);
            Utils.updateStatus(`❌ Failed to initialize map: ${error.message}`, 'error', 'init-status');
          }
        },

        createMap() {
          window.State.map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/streets-v12',
            center: [-74.0059, 40.7128], // New York City
            zoom: 10
          });

          window.State.map.on('load', () => {
            window.State.isInitialized = true;
            EventSystem.emit('mapLoaded');
            this.setupMapSources();
            Utils.updateStatus('✅ Map initialized successfully!', 'success', 'init-status');
            RouteFinderApp.ui.showApplicationUI();
          });

          window.State.map.on('error', (error) => {
            console.error('Mapbox error:', error);
            Utils.updateStatus('❌ Map loading failed. Please check your token.', 'error', 'init-status');
          });
        },

        setupMapSources() {
          // Add sources for routes and waypoints
          window.State.map.addSource('routes-source', {
            type: 'geojson',
            data: {
              type: 'FeatureCollection',
              features: []
            }
          });

          window.State.map.addSource('waypoints-source', {
            type: 'geojson',
            data: {
              type: 'FeatureCollection',
              features: []
            }
          });

          // Add layers for routes
          window.State.map.addLayer({
            id: 'routes-layer',
            type: 'line',
            source: 'routes-source',
            layout: {
              'line-join': 'round',
              'line-cap': 'round'
            },
            paint: {
              'line-color': ['get', 'color'],
              'line-width': ['get', 'width'],
              'line-opacity': 0.8
            }
          });

          // Add layers for waypoints
          window.State.map.addLayer({
            id: 'waypoints-layer',
            type: 'circle',
            source: 'waypoints-source',
            paint: {
              'circle-radius': 8,
              'circle-color': ['get', 'color'],
              'circle-stroke-color': '#ffffff',
              'circle-stroke-width': 2
            }
          });
        }
      },

      // UI Management module
      ui: {
        init() {
          EventSystem.on('routeCreated', () => this.updateRouteTabs());
          EventSystem.on('routeDeleted', () => this.updateRouteTabs());
          EventSystem.on('routeSwitched', () => this.updateCurrentRoutePanel());
          EventSystem.on('routesUpdated', () => this.updateRouteTabs());
          EventSystem.on('waypointAdded', () => this.updateWaypointsList());
          EventSystem.on('waypointRemoved', () => this.updateWaypointsList());
          EventSystem.on('mapLoaded', () => this.showApplicationUI());
          EventSystem.on('routesImported', () => {
            this.updateRouteTabs();
            this.updateRouteList();
          });
        },

        setupCollapsibleSections() {
          // Initialize all sections as expanded
          const sections = ['route-management', 'current-route', 'map-controls'];
          sections.forEach(sectionId => {
            const content = document.getElementById(`${sectionId}-content`);
            if (content) {
              content.style.maxHeight = content.scrollHeight + 'px';
            }
          });
        },

        toggleSection(sectionId) {
          const content = document.getElementById(sectionId);
          const chevron = content.parentNode.querySelector('.chevron');
          
          if (content.style.maxHeight && content.style.maxHeight !== '0px') {
            content.style.maxHeight = '0px';
            chevron.classList.remove('expanded');
          } else {
            content.style.maxHeight = content.scrollHeight + 'px';
            chevron.classList.add('expanded');
          }
        },

        showApplicationUI() {
          document.getElementById('route-management').style.display = 'block';
          document.getElementById('current-route-panel').style.display = 'block';
          document.getElementById('map-controls').style.display = 'block';
          document.getElementById('obstacle-controls').style.display = 'block';

          // Hide init controls after delay
          setTimeout(() => {
            document.getElementById('init-controls').style.display = 'none';
          }, 2000);
        },

        showInitializationError(message) {
          const statusEl = document.getElementById('init-status');
          statusEl.textContent = `❌ Initialization failed: ${message}`;
          statusEl.className = 'status-message error';
          statusEl.style.display = 'block';
        },

        updateRouteTabs() {
          const tabsContainer = document.getElementById('route-tabs');
          tabsContainer.innerHTML = '';

          window.State.routes.forEach(route => {
            const tab = document.createElement('div');
            tab.className = `route-tab ${route.id === window.State.currentRouteId ? 'active' : ''}`;
            tab.onclick = () => RouteFinderApp.routes.switchToRoute(route.id);
            
            tab.innerHTML = `
              <div class="route-color-indicator" style="background-color: ${route.color};"></div>
              <span>${route.name}</span>
              ${window.State.routes.size > 1 ? `<button onclick="event.stopPropagation(); RouteFinderApp.routes.deleteRoute(${route.id})" style="margin-left: 8px; background: none; border: none; color: inherit; cursor: pointer;">×</button>` : ''}
            `;
            
            tabsContainer.appendChild(tab);
          });

          this.updateRouteListToggle();
          this.updateRouteStylingControls();
        },

        updateCurrentRoutePanel() {
          const route = window.State.getCurrentRoute();
          if (!route) return;

          document.getElementById('travel-mode-select').value = route.travelMode;

          // Update route indicator
          const indicator = document.getElementById('current-route-indicator');
          indicator.innerHTML = `<div class="route-color-indicator" style="background-color: ${route.color};"></div>`;
          
          this.updateRouteStylingControls();
        },

        // STEP 1 FIX: New method to update route styling controls
        updateRouteStylingControls() {
          const route = window.State.getCurrentRoute();
          const stylingControls = document.getElementById('route-styling-controls');
          
          if (!route) {
            stylingControls.style.display = 'none';
            return;
          }
          
          stylingControls.style.display = 'block';
          document.getElementById('route-name-input').value = route.name;
          document.getElementById('route-color-input').value = route.color;
          document.getElementById('route-width-input').value = route.width;
        },

        updateRouteListToggle() {
          const toggle = document.getElementById('route-list-toggle');
          const routeList = document.getElementById('route-list');
          
          if (window.State.routes.size > 3) {
            toggle.style.display = 'block';
            this.updateRouteList();
          } else {
            toggle.style.display = 'none';
            routeList.style.display = 'none';
          }
        },

        toggleRouteList() {
          const routeList = document.getElementById('route-list');
          const toggle = document.getElementById('route-list-toggle');
          
          if (routeList.style.display === 'none') {
            routeList.style.display = 'block';
            toggle.textContent = '▲ Hide All Routes';
            this.updateRouteList();
          } else {
            routeList.style.display = 'none';
            toggle.textContent = '⋯ Show All Routes';
          }
        },

        updateRouteList() {
          const listContainer = document.getElementById('route-list');
          listContainer.innerHTML = '';

          window.State.routes.forEach(route => {
            const item = document.createElement('div');
            item.className = 'route-item';
            
            item.innerHTML = `
              <div class="route-color-indicator" style="background-color: ${route.color};"></div>
              <span class="route-name">${route.name}</span>
              <div class="route-controls">
                <button class="btn btn-small" style="opacity: ${route.visible ? '1' : '0.5'};" onclick="RouteFinderApp.routes.toggleVisibility(${route.id})" title="${route.visible ? 'Hide' : 'Show'} route">
                  ${route.visible ? '👁️' : '👁️‍🗨️'}
                </button>
                <button class="btn btn-small" onclick="RouteFinderApp.routes.switchToRoute(${route.id})" title="Switch to route">
                  📍
                </button>
                <button class="btn btn-small btn-danger" onclick="RouteFinderApp.routes.deleteRoute(${route.id})" title="Delete route">
                  🗑️
                </button>
              </div>
            `;
            
            listContainer.appendChild(item);
          });
        },

        updateWaypointsList() {
          const route = window.State.getCurrentRoute();
          const waypointsList = document.getElementById('waypoints-list');
          
          if (!route || route.waypoints.length === 0) {
            waypointsList.style.display = 'none';
            return;
          }
          
          waypointsList.style.display = 'block';
          waypointsList.innerHTML = `
            <label class="form-label">Waypoints (${route.waypoints.length})</label>
          `;
          
          route.waypoints.forEach((waypoint, index) => {
            const item = document.createElement('div');
            item.className = 'waypoint-item';
            
            item.innerHTML = `
              <span class="waypoint-address">${index + 1}. ${waypoint.address}</span>
              <div class="waypoint-controls">
                <button class="btn btn-small btn-danger" onclick="RouteFinderApp.routes.removeWaypoint(${index})" title="Remove waypoint">
                  ×
                </button>
              </div>
            `;
            
            waypointsList.appendChild(item);
          });
        }
      },

      // Routes management module
      routes: {
        createNewRoute() {
          const newRoute = Utils.createEmptyRoute();
          window.State.routes.set(newRoute.id, newRoute);
          
          this.switchToRoute(newRoute.id);
          
          EventSystem.emit('routeCreated', newRoute);
          EventSystem.emit('routesUpdated');
          
          console.log(`Created new route ${newRoute.id}`);
        },

        switchToRoute(routeId) {
          const route = window.State.routes.get(routeId);
          if (!route) return;
          
          window.State.currentRouteId = routeId;
          
          EventSystem.emit('routeSwitched', route);
          EventSystem.emit('waypointsUpdated');
        },

        deleteRoute(routeId) {
          if (window.State.routes.size <= 1) {
            Utils.updateStatus('❌ Cannot delete the last route', 'error');
            return;
          }
          
          const routeName = window.State.routes.get(routeId)?.name || 'Unknown';
          
          if (!confirm(`Delete "${routeName}"?`)) {
            return;
          }
          
          window.State.routes.delete(routeId);
          
          // Switch to another route if we deleted the current one
          if (window.State.currentRouteId === routeId) {
            const remainingRoute = window.State.routes.values().next().value;
            if (remainingRoute) {
              this.switchToRoute(remainingRoute.id);
            }
          }
          
          this.updateRoutesOnMap();
          
          EventSystem.emit('routeDeleted', routeId);
          EventSystem.emit('routesUpdated');
          
          Utils.updateStatus(`✅ Deleted route "${routeName}"`, 'success');
        },

        // STEP 1 FIX: Updated method to use consolidated controls
        updateRouteName() {
          const route = window.State.getCurrentRoute();
          if (!route) return;
          
          const newName = document.getElementById('route-name-input').value.trim();
          if (newName) {
            route.name = newName;
            EventSystem.emit('routesUpdated');
          }
        },

        // STEP 1 FIX: Updated method to use consolidated controls
        updateRouteStyle() {
          const route = window.State.getCurrentRoute();
          if (!route) return;
          
          route.color = document.getElementById('route-color-input').value;
          route.width = parseInt(document.getElementById('route-width-input').value);
          
          this.updateRoutesOnMap();
          EventSystem.emit('routesUpdated');
        },

        updateTravelMode() {
          const route = window.State.getCurrentRoute();
          if (!route) return;
          
          route.travelMode = document.getElementById('travel-mode-select').value;
          
          // Recalculate route if waypoints exist
          if (route.waypoints.length >= 2) {
            this.calculateRoute();
          }
        },

        async addWaypoint() {
          const address = document.getElementById('address-input').value.trim();
          if (!address) {
            Utils.updateStatus('❌ Please enter an address', 'error');
            return;
          }
          
          const route = window.State.getCurrentRoute();
          if (!route) {
            Utils.updateStatus('❌ No active route', 'error');
            return;
          }
          
          Utils.updateStatus('🔍 Searching for location...', 'info');
          
          try {
            const coordinates = await this.geocodeAddress(address);
            
            const waypoint = {
              address: address,
              coordinates: coordinates
            };
            
            route.waypoints.push(waypoint);
            document.getElementById('address-input').value = '';
            
            EventSystem.emit('waypointAdded', waypoint);
            
            if (route.waypoints.length >= 2) {
              await this.calculateRoute();
            }
            
            Utils.updateStatus(`✅ Added waypoint: ${address}`, 'success');
            
          } catch (error) {
            console.error('Geocoding error:', error);
            Utils.updateStatus(`❌ Could not find location: ${address}`, 'error');
          }
        },

        async geocodeAddress(address) {
          const encodedAddress = encodeURIComponent(address);
          const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodedAddress}.json?access_token=${window.State.mapboxToken}&limit=1`;
          
          const response = await fetch(url);
          const data = await response.json();
          
          if (!data.features || data.features.length === 0) {
            throw new Error('Location not found');
          }
          
          return data.features[0].center;
        },

        async calculateRoute() {
          const route = window.State.getCurrentRoute();
          if (!route || route.waypoints.length < 2) return;
          
          Utils.updateStatus('🧭 Calculating route...', 'info');
          
          try {
            const coordinates = route.waypoints.map(wp => wp.coordinates.join(',')).join(';');
            const profile = route.travelMode === 'driving' ? 'driving' : route.travelMode === 'walking' ? 'walking' : 'cycling';
            
            const url = `https://api.mapbox.com/directions/v5/mapbox/${profile}/${coordinates}?geometries=geojson&access_token=${window.State.mapboxToken}`;
            
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.routes && data.routes.length > 0) {
              route.routeData = data.routes[0];
              route.status = 'calculated';
              
              this.updateRoutesOnMap();
              this.fitMapToRoute();
              
              const duration = Math.round(data.routes[0].duration / 60);
              const distance = (data.routes[0].distance / 1000).toFixed(1);
              
              Utils.updateStatus(`✅ Route calculated: ${distance}km, ${duration} minutes`, 'success');
            } else {
              throw new Error('No route found');
            }
            
          } catch (error) {
            console.error('Route calculation error:', error);
            Utils.updateStatus('❌ Could not calculate route', 'error');
          }
        },

        removeWaypoint(index) {
          const route = window.State.getCurrentRoute();
          if (!route) return;
          
          route.waypoints.splice(index, 1);
          
          EventSystem.emit('waypointRemoved', index);
          
          if (route.waypoints.length >= 2) {
            this.calculateRoute();
          } else {
            route.routeData = null;
            route.status = 'empty';
            this.updateRoutesOnMap();
          }
        },

        clearCurrentRoute() {
          const route = window.State.getCurrentRoute();
          if (!route) return;
          
          route.waypoints = [];
          route.routeData = null;
          route.status = 'empty';
          
          this.updateRoutesOnMap();
          
          EventSystem.emit('waypointsUpdated');
          
          Utils.updateStatus('✅ Route cleared', 'success');
        },

        toggleVisibility(routeId) {
          const route = window.State.routes.get(routeId);
          if (!route) return;
          
          route.visible = !route.visible;
          this.updateRoutesOnMap();
          EventSystem.emit('routesUpdated');
        },

        updateRoutesOnMap() {
          if (!window.State.map || !window.State.isInitialized) return;
          
          const routeFeatures = [];
          const waypointFeatures = [];
          
          window.State.routes.forEach(route => {
            if (route.visible && route.routeData) {
              routeFeatures.push({
                type: 'Feature',
                properties: {
                  id: route.id,
                  color: route.color,
                  width: route.width
                },
                geometry: route.routeData.geometry
              });
            }
            
            if (route.visible && route.waypoints.length > 0) {
              route.waypoints.forEach((waypoint, index) => {
                waypointFeatures.push({
                  type: 'Feature',
                  properties: {
                    id: `${route.id}-${index}`,
                    color: route.color,
                    address: waypoint.address
                  },
                  geometry: {
                    type: 'Point',
                    coordinates: waypoint.coordinates
                  }
                });
              });
            }
          });
          
          window.State.map.getSource('routes-source').setData({
            type: 'FeatureCollection',
            features: routeFeatures
          });
          
          window.State.map.getSource('waypoints-source').setData({
            type: 'FeatureCollection',
            features: waypointFeatures
          });
        },

        fitMapToRoute() {
          const route = window.State.getCurrentRoute();
          if (!route || !route.routeData) return;
          
          const coordinates = route.routeData.geometry.coordinates;
          const bounds = new mapboxgl.LngLatBounds();
          
          coordinates.forEach(coord => bounds.extend(coord));
          
          window.State.map.fitBounds(bounds, {
            padding: 50
          });
        }
      },

      // Map controls module
      mapControls: {
        async centerMap() {
          const location = document.getElementById('center-location').value.trim();
          if (!location) return;
          
          try {
            const coordinates = await RouteFinderApp.routes.geocodeAddress(location);
            window.State.map.flyTo({
              center: coordinates,
              zoom: 12
            });
            
            Utils.updateStatus(`✅ Centered map on ${location}`, 'success');
          } catch (error) {
            Utils.updateStatus(`❌ Could not find location: ${location}`, 'error');
          }
        },

        changeStyle() {
          const style = document.getElementById('map-style').value;
          window.State.map.setStyle(style);
        },

        setZoom() {
          const zoom = document.getElementById('zoom-level').value;
          document.getElementById('zoom-value').textContent = zoom;
          window.State.map.setZoom(zoom);
        }
      },

      // File management module
      fileManager: {
        exportRoutes() {
          if (window.State.routes.size === 0) {
            Utils.updateStatus('❌ No routes to export', 'error');
            return;
          }

          try {
            const exportData = {
              version: "1.0",
              exportDate: new Date().toISOString(),
              totalRoutes: window.State.routes.size,
              routes: window.State.getAllRoutes().map(route => ({
                id: route.id,
                name: route.name,
                origin: route.origin,
                destination: route.destination,
                waypoints: route.waypoints,
                travelMode: route.travelMode,
                color: route.color,
                width: route.width,
                visible: route.visible,
                status: route.status,
                routeStats: route.routeData ? {
                  duration: route.routeData.duration,
                  distance: route.routeData.distance
                } : null
              }))
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], {
              type: 'application/json'
            });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `routes-export-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            Utils.updateStatus(`✅ Exported ${window.State.routes.size} routes successfully`, 'success');

          } catch (error) {
            console.error('Export error:', error);
            Utils.updateStatus('❌ Export failed', 'error');
          }
        },

        triggerImportRoutes() {
          document.getElementById('route-file-input').click();
        },

        importRoutes() {
          const fileInput = document.getElementById('route-file-input');
          const file = fileInput.files[0];
          
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const importData = JSON.parse(e.target.result);
              
              if (!importData.routes || !Array.isArray(importData.routes)) {
                throw new Error('Invalid route data structure');
              }

              Utils.updateStatus('<strong>📥 Importing Routes...</strong><br>Processing route data', 'loading');

              if (window.State.routes.size > 0) {
                const confirmClear = confirm(`This will replace your current ${window.State.routes.size} route(s). Continue?`);
                if (!confirmClear) return;
              }

              // Clear existing routes
              window.State.routes.clear();

              // Import routes
              importData.routes.forEach(routeData => {
                const route = {
                  id: Utils.generateId(),
                  name: routeData.name || 'Imported Route',
                  origin: routeData.origin || null,
                  destination: routeData.destination || null,
                  waypoints: routeData.waypoints || [],
                  travelMode: routeData.travelMode || 'driving',
                  color: routeData.color || '#3b82f6',
                  width: routeData.width || 4,
                  visible: routeData.visible !== false,
                  status: routeData.status || 'empty',
                  routeData: null
                };
                
                window.State.routes.set(route.id, route);
              });

              // Set first route as current
              if (window.State.routes.size > 0) {
                const firstRoute = window.State.routes.values().next().value;
                window.State.currentRouteId = firstRoute.id;
              }

              EventSystem.emit('routesImported');
              
              Utils.updateStatus(`✅ Successfully imported ${importData.routes.length} routes`, 'success');

            } catch (error) {
              console.error('Import error:', error);
              Utils.updateStatus('❌ Import failed. Please check the file format.', 'error');
            }
          };

          reader.readAsText(file);
          fileInput.value = '';
        }
      },

      // Obstacle detection module
      obstacles: {
        toggleDetection() {
          window.State.obstacleDetection = !window.State.obstacleDetection;
          Utils.updateStatus(
            window.State.obstacleDetection ? '✅ Obstacle detection enabled' : '⭕ Obstacle detection disabled',
            window.State.obstacleDetection ? 'success' : 'warning',
            'obstacle-status'
          );
        },

        clearObstacles() {
          Utils.updateStatus('✅ Obstacles cleared', 'success', 'obstacle-status');
        }
      },

      // Map export module (placeholder for future implementation)
      mapExport: {
        showExportDialog() {
          Utils.updateStatus('📸 Map export feature coming soon!', 'info');
        }
      }
    };

    // Initialize application
    document.addEventListener('DOMContentLoaded', function() {
      RouteFinderApp.ui.init();
      RouteFinderApp.ui.setupCollapsibleSections();
      
      // Setup file input handler
      document.getElementById('route-file-input').addEventListener('change', RouteFinderApp.fileManager.importRoutes);
      
      // Setup keyboard shortcuts
      document.addEventListener('keydown', function(e) {
        if (e.ctrlKey || e.metaKey) {
          switch(e.key) {
            case 'e':
              e.preventDefault();
              if (RouteFinderApp.mapExport.isAvailable()) {
                RouteFinderApp.mapExport.showExportDialog();
              }
              break;
          }
        }
      });

      console.log('Route Finder App initialized successfully');
    });

    // Initialize when page loads
window.addEventListener('load', function() {
  console.log('Page loaded, ready for initialization');
  // Auto-initialize with hardcoded token
  RouteFinderApp.init.initializeApp();
});
  </script>
</body>
</html>
